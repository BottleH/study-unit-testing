# 6. 단위 테스트 스타일

### 단위 테스트의 세가지 스타일
> 하나의 테스트에서 하나 또는 두, 세가지 스타일 모두를 함께 사용 가능
* 출력 기반 테스트 (= 함수형)
  * SUT에 입력을 넣고 생성되는 출력을 점검하는 방식
  * 전역 상태나 내부 상태를 변경하지 않는 코드에만 적용되며, 반환 값만 검증하면 됨
  * 사이트 이펙트 없는 코드 선호를 강조하는 프로그래밍 방식인 함수형 프로그래밍에 뿌리를 두고있음
* 상태 기반 테스트
  * 작업이 완료된 후 시스템 상태를 확인하는 것
  * 상태 = 프로세스 외부 의존성의 상태등을 의미할 수 있음 (테이터베이스, 파일 시스템, SUT나 협력자 중 하나)
* 통신 기반 테스트
  * 목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증

### 단위 테스트 스타일 비교
#### 회귀 방지와 피드백 속도 지표로 스타일 비교
> 회귀 방지 지표 특성 :: 테스트 중에 실행되는 코드의 양 / 코드 복잡도 / 도메인 유의성

- 테스트 스타일과 테스트 피드백 속도 사이에는 상관관계가 거의 없음
- 목은 런타임에 지연 시간이 생기는 편이므로 통신 기반 테스트가 약간 나쁠 수 있으나, 이러한 테스트가 수만 개 수준이 아니라면 별로 차이 없음
#### 리팩터링 내성 지표로 스타일 비교하기
> 리팩터링 내성은 리팩터링 중에 발생하는 거짓양성 수에 대한 척도
> 거짓 양성은 식별할 수 있는 동작이 아니라 코드의 구현 세부 사항에 결합된 테스트의 결과

- 출력 기반 테스트 
:: 테스트가 테스트 대상 메서드에만 결합되므로 거짓 양성 방지가 가장 우수함
:: 테스트가 구현 세부사항에 결합 하는 경우는 테스트 대상 메서드가 구현 세부사항일 떄 뿐

- 상태 기반 테스트
:: 일반적으로 거짓 양성이 되기 쉬움
:: 테스트 대상 메서드 외에도 클래스 상태와 함께 작동 

- 통신 기반 테스트
:: 거짓 양성에 가장 취약함
:: 애플리케이션 경계를 넘는 상호 작용을 확인하고 해당 상호 작용의 사이드 이펙트가 외부 환경에 보이는 경우에만 목이 괜찮음
:: 캡슐화를 잘 지키고ㅗ 테스트를 식별할 수 있는 동작에만 결합하면 거짓양성 죄소화 가능

#### 유지 보수성 지표로 스타일 비교하기
> 단위 테스트 스타일과 밀접한 관련이 있음
> 리팩터링 내성과 달리 완화할 수 있는 방법이 많지 않음

- 출력 기반 테스트
:: 유지 보수에 가장 용이 (보통 거의 항상 짧고 간결함)
:: 기반 코드가 전역 상태나 내부 상태를 변경할 리 없으므로, 프로세스 외부 의존성을 다루지 않음

- 상태 기반 테스트
:: 상태 검증은 종종 출력 검증보다 더 많은 공간을 차지함 (출력 기반 테스트보다 유지 보수성이 쉽지 않음)

- 통신 기반 테스트
:: 테스트 대역과 상호 작용 검증 설정이 필요 = 공간을 많이 차지
:: 목이 사슬 형태로 있을 때 테스트는 더 커지고 유지 보수하기가 어려워짐

~~~
결론
회귀 방지, 피스팩 속도 : 출력 기반 = 상태 기반 = 통신 기반
리팩터링 내성 : 출력 기반 > 상태 기반 > 통신 기반
유지 보수성 : 출력 기반 > 상태 기반 > 통신 기반

최종 결론 : 출력 기반 테스트가 여러 요소에서 가장 지표가 좋음
~~~

### 함수형 아키텍처
 
- 함수형 프로그래밍
> 수학적 함수(숨은 입출력이 없는 함수)를 사용한 프로그래밍 

<수학적 함수>
  - 수학적 함수의 모든 입출력은 메서드 이름, 인수, 반환 타입으로 구성된 메서드 시그니처에 명시해야 함
  - 수학적 함수는 호출 횟수에 상관없이 주어진 입력에 대해 동일한 출력을 생성 해야 함
  - 입출력을 명시한 수학적 함수는 이에 따르는 테스트가 짧고 간결하며 이해하고 유지보수하기 쉬우므로 테스트하기가 매우 쉬움
  - 유지보수성이 좋고 거짓 양성 빈도가 낮음

< 숨은 입출력 유형 >
  - 사이드 이펙트 
    :: 메서드 시그니처에 표시되지 않은 출력
  - 예외 
    :: 호출된 예외는 호출 스택의 어느 곳에서도 발생할 수 있으므로, 메서드 시크니처가 전달하지 않는 출력을 추가함
  - 내외부 상태에 대한 참조
    :: 정적 송석을 사용해 현재 날짜와 시간을 가져오는 메서드가 있을 수 있음
    :: 메서드 시그니처에 없는 실행 흐름에 대한 입력이며, 따라서 숨어있다.
  
- 함수형 아키텍처
> 사이드 이펙트를 다루는 코드를 최소화하면서 순수 함수(불변) 방식으로 작성한 코드의 양을 극대화
> 함수형 코어와 가변셀로 이루어짐

<비즈니스 로직과 사이드 이펙트를 분리하는 유형>
1. 함수형 코어 
= 결정을 내리는 코드 (사이드 이펙트가 없기 떄문에 수학적 함수를 사용해 작성가능)
2. 가별 셀 
= 해당 결정에 따라 작용하는 코드 (수학적 함수에 의해 이뤄진 모든 결정을 가시적인 부분으로 변환)

* 함수형 코어와 가변 셀의 협력 방식
- 가변 셀은 모든 입력을 수집
- 함수형 코어는 결정을 생성
- 셀은 결정을 사이드 이펙트로 변환

위 두 계층을 계속 잘 분리하려면, 가변 셀이 의사 결정을추가하지 않게끔 결정을 나타내는 클래스에 정보가 충분히 있는지 확인 해야 함
목표는 출력 기반 테스트로 함수형 코어를 두루 다루고 가변 셀을 훨씬 더 적은 수의 통합 테스트에 맡기는것

### 함수형 아키텍처와 육각형 아키텍처 비교

- 공통점
  - 관심사 분리가는 아이디어를 기반으로 함
  - 의존선 간의 단방향 흐름
- 차이점
  - 함수형 아키텍처 (함수형 코어, 가변 셀로 분리), 육각형 아키텍처 (도메인 계층, 애플리케이션 서비스 계층으로 분리)
  - 사이드 이펙에 대한 처리
    - 함수형 :: 모든 사이드 이펙트를 (불변 코어 -> 연산 가장자리)로 밀어 냄
    - 육각형 :: 도메인 계층에 제한하는 한 도메인 계층으로 인한 사이드 이팩트로 문제 없음

### 함수형 아키텍처와 출력 기반 테스트로의 전환
> 두 가지 리팩터링 단계
> 1.프로세스 외부 의존성에서 목으로 변경
> 2.목에서 함수형 아키텍처로 변경

#### 감사 시스템(샘플 프로젝트) 소개
- 조직의 모든 방문자를 추적하는 감사 시스템
- 텍스트 파일을 기반 저장소로 사용
- 가장 최근 파일의 마지막 줄에 방문자의 이름과 방문 시간을 추가
- 파일당 최대 항목 수에 도달하면 인덱스를 증가시켜 새 파일을 작성

> 코드 => 6.단위 테스트 스타일 exampleCode/SampleCode_origin 

- AuditManager는 어플리케이션의 주요 클래스
- 생성자는 파일당 최대 항목 수(_maxEntriesPerFile)와 작업 디렉터리(_directoryName)를 설정 매개변수로 받는다.
- AuditManager에서의 공개 메서드는 AddReacord뿐이며, 감사 시스템의 모든 작업을 수행한다.

AuditManager 클래스는 파일 시스템과 밀접하게 연결돼 있어 그대로 테스트 하기 어려움
- 테스트 전에 파일을 올바른 위치에 배치
- 테스트가 끝나면 해당 파일을 읽고 내용을 확인할 후 삭제

-> 감사 시스템 초기 버전에 대한 테스트는 파일 시스템에 직접적으로 수행해야함
-> 병목지점은 파일시스템 (테스트가 실행 흐름을 방해할 수 있는 공유 의존성)

#### 테스트를 파일 시스템에서 분리하기 위한 목 사용
- 테스트가 밀접하게 결합된 문제는 일반적으로 목으로 처리해 해결한다.
- 파일의 모든 연산을 별도의 클래스로 도출하고 AuditManager에 생성자로 해당 클래스를 주입할 수 있다.

> 코드 => 6.단위 테스트 스타일 exampleCode/SampleCode_mock

- IFileSystem은 파일 시스템 작업을 캡슐화한 새로운 사용자 정의 인터페이스
- AuditManager가 파일 시스템에서 분리되므로, 공유 의존성이 사라지고 테스트를 서로 독립적으로 실행할 수 있다.

#### 함수형 아키텍처로 리팩터링 하기
- 인터페이스 뒤로 사이드 이첵트를 숨기고 해당 인터페이스를 AuditManager에 주입하는 대신, 사이드 이펙트를 클래스 외부로 완전히 이동
- AuditManager(함수형 코어)를 파일에 수행할 작업을 둘러싼 결정만 책임
- Persister(가변 셀)는 그 결정에 따라 파일 시스템에 업데이트를 적용

> 코드 => 6.단위 테스트 스타일 exampleCode/SampleCode_refactoring

- AuditManager는 이제 작업 디렉터리 경로 대신 FileContent 배열을 받는다.
- 이 클래스는 결정을 내리기 위해 차일 시스템에 대해 알아야 할 모든 것을 포함한다,
- 작업 디렉터리의 파일을 변경하는 대신, 이제 AuditManager는 수행하려는 사이드이펙트에 대한 명령을 반환한다.

||초기 버전|Mock 사용|출력 기반
|:---:|:---:|:---:|:---:
|회귀 방지|좋음|좋음|좋음
|리팩터링 내성|좋음|좋음|좋음
|빠른 피드백|나쁨|좋음|좋음
|유지 보수성|나쁨|중간|좋음

### 함수형 아키텍처의 단점 이해하기
> 함수형 아키텍처도 코드베이스가 커지고 성능에 영향을 미치면서 유지보수성의 이점이 상쇄된다.
#### 함수형 아티텍처 적용 가능성
숨은 입력이 생기면 수학적 함수가 될 수 없으며 출력 기반 테스트를 적용할 수 없다.

#### 성능 단점
함수형 아키텍처를 적용하면서 시스템은 프로세스 외부 의존성을 더 많이 호출하고 그 결과로 성능이 떨어진다.
> 성능 영향이 그다지 눈에 띄지 않는 일부 시스템에서는 함수형 아키텍처를 사용해 유지 보수성르 향상시키는 편이 좋음

#### 코드베이스 크기 증가
함수형 아키텍처는 함수형 코어와 가변 셀 사이를 명확하게 분리해야 한다.
궁극적으로 코드 복잡도가 낮아지고 유지 보수성이 향상되지만, 초기에 코딩이 더 필요하다.