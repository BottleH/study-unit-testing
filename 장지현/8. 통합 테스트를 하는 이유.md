# 8.통합 테스트를 하는 이유

## 통합 테스트는 무엇인가?
### 통합 테스트의 역할
* 대부분 시스템이 프로세스 외부 의존성과 통합해 어떻게 작동하는지를 검증
* 프로세스 외부 의존성과 도메인 모델을 연결하는 코드를 검증
~~~
단위 테스트의 3가지 요구사항
1. 단일동작 단위를 검증
2. 빠르게 수행
3. 다른 테스트와 별도로 처리

> 도메인 모델 검증
~~~

> 단위 테스트의 3가지 요구사항 중 하나라도 충족하지 못하는 테스트는 통합 테스트 범주에 속함
> 단위 테스트가 아닌 모든 테스트는 통합 테스트에 해당
### 다시 보는 테스트 피라미드
* 단위 테스트와 통합 테스트 간의 균형을 유지하는 것이 중요
> 단위 테스트 :: 가능한 한 많은 비즈니스 시나리오의 예외 상황 확인
> 통합 테스트 :: 주요 흐름과 단위 테스트가 다루지 못하는 기타 예외 상황 확인

#### 통합 테스트
< 장점 >
* 통합 테스트는 코드를 더 많이 거치므로 회귀 방지 우수
* 제품 코드와의 결합도가 낮아 리팩터링 내성 우수

< 단점 >
* 통합 테스트가 프로세스 외부 의존성에 직접 작동하면 느려짐 -> 유지비 증가
  * 유지비 증가 사유
    1. 프로세스 외부 의존성 운영 필요
    2. 테스트 크기 비대화 (관련 협력자 다수 존재)
#### 단위 테스트
< 장점 >
* 유지비 절감
* (통합 테스트 안에 단위 테스트 다수 존재 시)시스템의 정확도 보장 가능

#### 복잡도에 따른 테스트 피라미드 형태
> 단순한 어플리케이션 :: 직사각형의 형태 (도메인 모델 및 알고리즘 사분면에 거의 코드가 존재 하지 않음)
> 복잡한 어플리케이션 :: 피라미드 형태
* 통합 테스트는 단순한 어플리케이션에서도 가치 존재
* 코드의 단순성 보다 다른 서브 시스템과 통합해 어떻게 작동하는지 확인

### 통합 테스트와 빠른 실패
> 통합 테스트에서 프로세스 외부 의존성과의 상호 작용을 모두 확인하려면 가장 긴 주요 흐름을 선택
> 모든 상호 작용을 거치는 흐름이 없으면, 외부 시스템과의 통신을 모두 확인하는데 필요한 만큼 통합 테스트를 추가로 작성
> 어떠한 예외 상황에서 잘못 실행돼 전체 애플리케이션이 즉시 실패하면 해당 예외 상황은 테스트할 필요가 없다.
> > 좋지 않은 테스트를 작성하는 것보다는 테스트를 작성하지 않는 것이 좋다. 가치가 별로 없는 테스트는 좋지 않은 테스트다

~~~
* 버그를 빨리 나타나게 하는것 = 빠른 실패 원칙
예기치 않은 오류가 발생하자마자 현재 연산을 중단하는 것을 의미
<애플리케이션의 안정성을 높이는 방안>
1. 피드백 루프 단축 : 버그를 빨리 발견할수록 더 쉽게 해결할 수 있다.
2. 지속성 상태 보호 : 버그는 애플리케이션 상태를 손상시킨다. 빨리 실패하면 손상이 확산되는 것을 막을 수 있다.
~~~

## 어떤 프로세스 외부 의존성을 직접 테스트해야 하는가?
> 통합 테스트는 시스템이 프로세스 외부 의존성과 어떻게 통합하는지를 검증한다.

* 통합 테스트 겅증 구현 방식
  1. 실제 프로세스 외부 의존성을 사용
  2. 의존성을 목으로 대체

* 외부 의존성의 두가지 유형
  * 관리 의존성 : 전체를 제어할 수 있는 프로세스 외부 의존성
    * 애플리케이션을 통해서만 접근 가능
    * 해당 의존성과의 상호 작용은 외부 환경에서 확인 불가능
    * ex> database
    * 구현 세부 사항
  * 비관리 의존성 : 전체를 제어할 수 없는 프로세스 외부 의존성
    * 해당 의존성과의 상호 작용을 외부에서 볼 수 있다.
    * ex> SMTP 서버 or 메시지 버스
    * 통신 패턴 유지 필요 (하위호환성을 지키기 위해)
  
> 관리 의존성 -> 실제 프로세스 외부 의존성을 사용 :: 시스템의 최종상태를 클라이언트 입장에서 확인 가능
> 비관리 의존성 -> 의존성을 목으로 대체 :: 모든 가능한 리팩터링을 고려해서 통신 패턴 영속성 보장 가능

### 관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기
> 관리 의존성과 비관리 의존성 모두의 속성을 나타내는 프로세스 외부 의존성이 존재 가능
> ex> 다른 애플리케이션이 접근할 수 있는 데이터베이스
* 다른 애플리케이션에서 볼 수 있는 의존성(데이터베이스)을 비관리 의존성으로 취급 -> 목을 이용하여 대체
* 데이터베이스와의 상호 작용을 검증하지 말고 데이터베이스의 최종 상태를 확인

### 통합 테스트에서 실제 데이터베이스를 사용할 수 없으면 어떻게 할까?
* 컨트롤러가 어떤 리포지터리 메서드를 호출하는지 검증하는 방법 뿐
* 데이터베이스를 그대로 테스트할 수 없으면 통합 테스트를 아예 작성하지 말고 도메인 모델의 단위 테스트에만 집중
* 가치가 출분하지 않은 테스트는 테스트 스위트에 있어서는 안된다.

## 통합 테스트: 예제
> 사용자 이메일 변경 기능 구현
1. 데이터베이스에서 사용자와 회사를 검색
2. 의사 결정을 도메인 모델에 위임
3. 결과를 데이터베이스에 다시 저장
4. 필요시 메시지 버스 이용

### 어떤 시나리오를 테스트할까?
> 통함 테스트의 일반적인 지침 :: 가장 긴 주요 흐름과 단위 테스트로는 수행할 수 없는 모든 예외 상황을 다루는 것
> 가장 긴 주요 흐름은 모든 프로세스 외부 의존성을 거치는 것

해당 프로젝트에서 가장 긴 주요 흐름은 기업 이메일에서 일반 이메일로 변경하는 것
- 데이터베이스에서 사용자와 회사 모두 업데이트 (사용자는 유형을 변겨으 회사는 직원 수를 변경)
- 메세지 버스로 메시지를 보냄

단위 테스트로 테스트하지 않는 한 가지 예외 상황
- 이메일을 변경할 수 업는 시나리오

### 데이터베이스와 메시지버스 분류하기
> 통합 테스트를 작성하기 전에 프로세스 외부 의존성을 두 가지로 분류해서 직접 테스트할 대상과 목으로 대체할 대상을 결정
- 데이터베이스 :: 관리 의존성
- 메시지 버스 :: 비관리 의존성

### 엔드 투 엔드 테스트는 어떤가?
- 샘플 프로젝트에는 엔드 투 엔드 테스트가 없음
- API로 시나리오를 엔트 투 엔트 테스트하면 배포해서 모두 작동하는 버전의 API로 테스트 -> 어떤 프로세스 외부 의존성도 목으로 대체하지 않는 것을 의미
- 반면, 통합 테스트는 동일한 프로세스 내에서 애플리케이션을 호스팅하고 비관리 의존성을 목으로 대체

## 의존성 추상화를 위한 인터페이스 사용
### 인터페이스와 느슨한 결함
* 인터페이스를 사용하는 일반적인 이유 ( 저자의 의견: 하위의 2가지 이유는 오해에서 비롯됨)
1. 프로세스 외부 의존성을 추상화해 느슨한 결합을 달성
   저자 의견 : 단일 구현을 위한 인터페이스는 추상화가 아니며, 해당 인터페이스를 구현하는 구체 클래스보다 결합도가 낮지 않음
2. 기존 코드를 변경하지 않고 새로운 기능을 추가해 공개 폐쇄 원칙을 지키기 때문
   저자 의견 : 더 기존적인 원칙인 YAGNI를 위반함 (YAGNI : 현재 필요하지 않는 기능에 시간을 들이지 말라는 것이다.)
    
### 프로세스 외부 의존선에 인터페이스를 사용하는 이유는 무엇인가?
* 목을 사용하기 위해 사용
> 인터페이스가 없으면 테스트 대역을 만들 수 없으므로 테스트 대상 시스템과 프로세스 외부 의존성 간의 상호 작용을 확인할 수 없다.
* 의존성을 목으로 처리할 필요가 없는 한, 프로세스 외부 의존성에 대한 인터페이스를 두지 말라.
> 비관리 의존성에 대해서만 인터페이스를 쓰고, 관리 의존성을 구체 클래스로 사용

## 통합 테스트 모범 사례
### 도메인 모델 경계 명시하기
* 도메인 모델 :: 프로젝트가 해결하고자 하는 문제에 대한 도메인 지식의 모음
* 도메인 모델에 명시적 경계를 지정하면 코드의 해당 부분을 더 잘 보여주고 더 잘 설명할 수 있다.
* 도메인 클래스와 컨트롤러 사이의 명확한 경계로 단위 테스트와 통합 테스트의 차이점을 쉽게 구별 할 수 있다.

### 계층 수 줄이기
* 애플리케이션의 추상 계층이 너무 많으면 코드베이스를 탐색하기 어렵다.
* 간단한 연산이라 해도 숨은 로직을 이해하기가 너무 어려워진다.
* 간접 계층은 코드를 추론하는데 부정적인 영향을 미친다.
* 간접 계층이 많은 코드베이스는 컨트롤러와 도메인 모델 사이에 명확한 경게가 없는 편이다.
* 각 계층을 따로 검증하는 경향이 강하고 이로 인해 통함 테스트 가치가 떨어진다.

### 순한 의존성 제거하기
* 코드베이스의 유지 보수성을 대폰 개선하고 테스트를 더 쉽게 할 수 있는 방법
* 순환 의존성을 코드를 읽고 이해하려고 할 때 알아야 할 것이 많아서 부담이 됨
* 해결을 위한 출발점이 명확하지 않음
* 클래스 그래프를 나눠서 동작 단위를 하나 분리하려면 인터페이스에 의존해 목으로 처리 하는 경우가 대다수 -> 도메인 모델을 테스트할 때 사용하면 안됨


### 테스트에서 다중 실행 구절 사용
* 테스트에서 두 개 이상의 준비나 실행 또는 검증 구절을 두는 것은 코드 악취에 해당
* 테스트의 유지 보수성을 저해하는 신호 (테스트가 초점을 잃고 비대해 질 수 있음)
* 각 실행을 고유의 테스트로 추출해 나누는 것이 좋음
* 각 테스트가 단일 동작 단위에 초점을 맞추게 하면, 테스트를 더 쉽게 이해하고 수정 가능


## 로깅 기능을 테스트 하는 방법
### 로깅을 테스트해야 하는가?
* 로깅은 횡단 기능으로 코드 베이스 어느 부분에서나 필요로 할 수 있음
* 로깅은 너무 보편적이므로 테스트 노력을 더 들일 가치가 있는지 분명하지 않음
  * 발생 가능한 사이드 이펙트가 사용자에게 노출된다면(= 식별할 수 있는 동작) -> 반드시 테스트 필요
  * 발생 가능한 사이드 이펙트가 개발자에게만 노출된다면(= 구현 세부 사항) -> 테스트 필요x

### 로깅을 어떻게 테스트 해야 하는가?
* 로깅은 프로세스 외부 의존성이 있기 때문에 테스트에 관해서는 프로세스 외부 의존성에 영향을 주는 다른 기능과 동일한 규칙이 적용된다. (목 사용)

#### 구조화된 로깅 이해하기
* 구조화된 로깅은 로그 데이터 캡쳐와 렌더링을 분리하는 로깅 기술이다.
- 전통적인 로깅은 간단한 텍스트로 작동한다.
  문제점 : 구조상 결과 로그 파일을 분석하기 어려움 (분석을 위한 전문 도구 필요)
- 구조화된 로깅은 로그 저장소에 구조가 존재함
  장점 : 분석이 쉽다.

### 로깅이 얼마나 많으면 충분한가?
* 지원 로깅 = 비즈니스 요구사항 만큼
* 진단 로깅 = 처리되지 않는 예외에 대해서만 진단 로깅 사용 (이상적 사용량)
  * 과도한 로깅의 단점
    * 코드 혼잡도 증가 (코드가 모호해 짐)
    * 로그가 많을 수록 관련 정보 탐색에 어려움이 커짐 (로그의 신호 대비 잡음 비율 최소화)
  * 도메인 모델에서는 진단 로깅 절대 사용 금지
  * 디버깅 시에만 일시적으로 사용하는 방안 추천(디버깅 종료시 제거)
