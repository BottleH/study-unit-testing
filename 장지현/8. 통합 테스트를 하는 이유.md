# 8.통합 테스트를 하는 이유

## 통합 테스트는 무엇인가?
### 통합 테스트의 역할
* 대부분 시스템이 프로세스 외부 의존성과 통합해 어떻게 작동하는지를 검증
* 프로세스 외부 의존성과 도메인 모델을 연결하는 코드를 검증
~~~
단위 테스트의 3가지 요구사항
1. 단일동작 단위를 검증
2. 빠르게 수행
3. 다른 테스트와 별도로 처리

> 도메인 모델 검증
~~~

> 단위 테스트의 3가지 요구사항 중 하나라도 충족하지 못하는 테스트는 통합 테스트 범주에 속함
> 단위 테스트가 아닌 모든 테스트는 통합 테스트에 해당
### 다시 보는 테스트 피라미드
* 단위 테스트와 통합 테스트 간의 균형을 유지하는 것이 중요
> 단위 테스트 :: 가능한 한 많은 비즈니스 시나리오의 예외 상황 확인
> 통합 테스트 :: 주요 흐름과 단위 테스트가 다루지 못하는 기타 예외 상황 확인

#### 통합 테스트
< 장점 >
* 통합 테스트는 코드를 더 많이 거치므로 회귀 방지 우수
* 제품 코드와의 결합도가 낮아 리팩터링 내성 우수

< 단점 >
* 통합 테스트가 프로세스 외부 의존성에 직접 작동하면 느려짐 -> 유지비 증가
  * 유지비 증가 사유
    1. 프로세스 외부 의존성 운영 필요
    2. 테스트 크기 비대화 (관련 협력자 다수 존재)
#### 단위 테스트
< 장점 >
* 유지비 절감
* (통합 테스트 안에 단위 테스트 다수 존재 시)시스템의 정확도 보장 가능

#### 복잡도에 따른 테스트 피라미드 형태
> 단순한 어플리케이션 :: 직사각형의 형태 (도메인 모델 및 알고리즘 사분면에 거의 코드가 존재 하지 않음)
> 복잡한 어플리케이션 :: 피라미드 형태
* 통합 테스트는 단순한 어플리케이션에서도 가치 존재
* 코드의 단순성 보다 다른 서브 시스템과 통합해 어떻게 작동하는지 확인

### 통합 테스트와 빠른 실패
> 통합 테스트에서 프로세스 외부 의존성과의 상호 작용을 모두 확인하려면 가장 긴 주요 흐름을 선택
> 모든 상호 작용을 거치는 흐름이 없으면, 외부 시스템과의 통신을 모두 확인하는데 필요한 만큼 통합 테스트를 추가로 작성
> 어떠한 예외 상황에서 잘못 실행돼 전체 애플리케이션이 즉시 실패하면 해당 예외 상황은 테스트할 필요가 없다.
> > 좋지 않은 테스트를 작성하는 것보다는 테스트를 작성하지 않는 것이 좋다. 가치가 별로 없는 테스트는 좋지 않은 테스트다

~~~
* 버그를 빨리 나타나게 하는것 = 빠른 실패 원칙
예기치 않은 오류가 발생하자마자 현재 연산을 중단하는 것을 의미
<애플리케이션의 안정성을 높이는 방안>
1. 피드백 루프 단축 : 버그를 빨리 발견할수록 더 쉽게 해결할 수 있다.
2. 지속성 상태 보호 : 버그는 애플리케이션 상태를 손상시킨다. 빨리 실패하면 손상이 확산되는 것을 막을 수 있다.
~~~

## 어떤 프로세스 외부 의존성을 직접 테스트해야 하는가?
> 통합 테스트는 시스템이 프로세스 외부 의존성과 어떻게 통합하는지를 검증한다.

* 통합 테스트 겅증 구현 방식
  1. 실제 프로세스 외부 의존성을 사용
  2. 의존성을 목으로 대체

* 외부 의존성의 두가지 유형
  * 관리 의존성 : 전체를 제어할 수 있는 프로세스 외부 의존성
    * 애플리케이션을 통해서만 접근 가능
    * 해당 의존성과의 상호 작용은 외부 환경에서 확인 불가능
    * ex> database
    * 구현 세부 사항
  * 비관리 의존성 : 전체를 제어할 수 없는 프로세스 외부 의존성
    * 해당 의존성과의 상호 작용을 외부에서 볼 수 있다.
    * ex> SMTP 서버 or 메시지 버스
    * 통신 패턴 유지 필요 (하위호환성을 지키기 위해)
  
> 관리 의존성 -> 실제 프로세스 외부 의존성을 사용 :: 시스템의 최종상태를 클라이언트 입장에서 확인 가능
> 비관리 의존성 -> 의존성을 목으로 대체 :: 모든 가능한 리팩터링을 고려해서 통신 패턴 영속성 보장 가능

### 관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기
> 관리 의존성과 비관리 의존성 모두의 속성을 나타내는 프로세스 외부 의존성이 존재 가능
> ex> 다른 애플리케이션이 접근할 수 있는 데이터베이스
* 다른 애플리케이션에서 볼 수 있는 의존성(데이터베이스)을 비관리 의존성으로 취급 -> 목을 이용하여 대체
* 데이터베이스와의 상호 작용을 검증하지 말고 데이터베이스의 최종 상태를 확인

### 통합 테스트에서 실제 데이터베이스를 사용할 수 없으면 어떻게 할까?
* 컨트롤러가 어떤 리포지터리 메서드를 호출하는지 검증하는 방법 뿐
* 데이터베이스를 그대로 테스트할 수 없으면 통합 테스트를 아예 작성하지 말고 도메인 모델의 단위 테스트에만 집중
* 가치가 출분하지 않은 테스트는 테스트 스위트에 있어서는 안된다.

## 통합 테스트: 예제
> 사용자 이메일 변경 기능 구현
1. 데이터베이스에서 사용자와 회사를 검색
2. 의사 결정을 도메인 모델에 위임
3. 결과를 데이터베이스에 다시 저장
4. 필요시 메시지 버스 이용

### 어떤 시나리오를 테스트할까?
> 통함 테스트의 일반적인 지침 :: 가장 긴 주요 흐름과 단위 테스트로는 수행할 수 없는 모든 예외 상황을 다루는 것
> 가장 긴 주요 흐름은 모든 프로세스 외부 의존성을 거치는 것

해당 프로젝트에서 가장 긴 주요 흐름은 기업 이메일에서 일반 이메일로 변경하는 것
- 데이터베이스에서 사용자와 회사 모두 업데이트 (사용자는 유형을 변겨으 회사는 직원 수를 변경)
- 메세지 버스로 메시지를 보냄

단위 테스트로 테스트하지 않는 한 가지 예외 상황
- 이메일을 변경할 수 업는 시나리오

### 데이터베이스와 메시지버스 분류하기
> 통합 테스트를 작성하기 전에 프로세스 외부 의존성을 두 가지로 분류해서 직접 테스트할 대상과 목으로 대체할 대상을 결정
- 데이터베이스 :: 관리 의존성
- 메시지 버스 :: 비관리 의존성

### 엔드 투 엔드 테스트는 어떤가?
- 샘플 프로젝트에는 엔드 투 엔드 테스트가 없음
- API로 시나리오를 엔트 투 엔트 테스트하면 배포해서 모두 작동하는 버전의 API로 테스트 -> 어떤 프로세스 외부 의존성도 목으로 대체하지 않는 것을 의미
- 반면, 통합 테스트는 동일한 프로세스 내에서 애플리케이션을 호스팅하고 비관리 의존성을 목으로 대체

## 의존성 추상화를 위한 인터페이스 사용
### 인터페이스와 느슨한 결함
* 인터페이스를 사용하는 일반적인 이유 ( 저자의 의견: 하위의 2가지 이유는 오해에서 비롯됨)
1. 프로세스 외부 의존성을 추상화해 느슨한 결합을 달성
   저자 의견 : 단일 구현을 위한 인터페이스는 추상화가 아니며, 해당 인터페이스를 구현하는 구체 클래스보다 결합도가 낮지 않음
2. 기존 코드를 변경하지 않고 새로운 기능을 추가해 공개 폐쇄 원칙을 지키기 때문
   저자 의견 : 더 기존적인 원칙인 YAGNI를 위반함 (YAGNI : 현재 필요하지 않는 기능에 시간을 들이지 말라는 것이다.)
    
### 프로세스 외부 의존선에 인터페이스를 사용하는 이유는 무엇인가?
* 목을 사용하기 위해 사용
> 인터페이스가 없으면 테스트 대역을 만들 수 없으므로 테스트 대상 시스템과 프로세스 외부 의존성 간의 상호 작용을 확인할 수 없다.
* 의존성을 목으로 처리할 필요가 없는 한, 프로세스 외부 의존성에 대한 인터페이스를 두지 말라.
> 비관리 의존성에 대해서만 인터페이스를 쓰고, 관리 의존성을 구체 클래스로 사용
