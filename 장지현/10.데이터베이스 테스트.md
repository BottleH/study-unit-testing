# 10.데이터베이스 테스트
> 데이터베이스를 테스트 하면 회귀방지가 아주 뛰어나지만 설정하기가 쉽지 않다.

## 데이터 베이스 테스트를 위한 전제 조건
### 형상 관리 시스템에 데이터베이스 유지
  * 데이터베이스 스키마를 일반 코드로 취급(형상관리 시스템에 저장)
  * 모델 데이터베이스를 사용하는 것은 데이터베이스 스키마를 유지하는데 좋지 않은 방법
    * 변경 내역 부재 : 스키마를 과거의 특정 시점으로 되돌릴 수 없다.(버그 재현에 중요 요소)
    * 복수의 원천 정보 : 개발 상태에 대한 원천 정보를 둘러싸고 경합한다.(부담 가중화)
    > 모든 데이터베이스 스키마 업데이트를 형상 관리 시스템에 두면 원천 정보를 하나로 할 수 있고 변경을 추적할 수 있다.

  * 참조 데이터도 데이터베이스 스키마
    > 참조 데이터 = 애플리케이션이 제대로 작동하도록 미리 채워야 하는 데이터
    > 애플리케이션이 데이터를 수정할 수 있다면 일반데이터, 없다면 참조 데이터
    * 참조 데이터는 애플리케이션의 필수 사항이므로, 테이블, 뷰 그리고 다른 데이터베이스 스키마와 함께 sql insert형태로 형상 관리 시스템에 저장해야 함

  * 모든 개발자를 위한 별도의 데이터베이스 인스턴스 사용
    * 공유 데이터베이스를 사용하면 개발 프로세스를 방해하게 된다.
      * 서로 다른 개발자가 실행한 테스트는 서로 간섭됨
      * 하위 호환성이 없는 변경으로 다른 개발자의 작업을 막을 수 있음
    * 테스트 실행 속도를 극대화하려면 개발자 마다 별도로 베이터베이스 인스터스를 사용하는것이 좋다.

  * 데이터베이스 배포에 마이그레이션 기반 방식 적용
    * 데이터베이스 배포 방식
    1. 상태 기반 방식
       개발 내내 유지보수하는 모델 데이터베이스가 있음
       배포 중 비교 도구가 스크립트를 생성해서 운영 데이터베이스를 모델 데이터베이스와 비교해 최신 상태로 유지
       물리적인 모델 데이터 베이스 != 원천 데이터
       데이터베이스 작성에 사용할 수 있는 sql 스크립트 존재(형상관리에 저장) 
       > 상태를 형상 관리에 저장함으로써 상태를 명시하고 비교 도구가 마이그레이션을 암묵적으로 제어할 수 있게 함
       > 병합 출돌을 처리하기가 수월
     
    2. 마이그레이션 기반
       데이터베이스를 어떤 버전에서 다른 버전으로 전환하는 명시적인 마이그레이션을 의미
       자동 동기화 도구 사용 불가, 업그레이드 스크립트를 직접 작성(산출물의 역할도 수행)
       > 마이그렝션을 명시적으로 하지만 상태를 암묵적으로 둔다.
       > 데이터베이스 상태를 직접 볼 수 없으며 마이그레이션으로 조합해야 한다.
       > 데이터 모션(새로운 데이터베이스 스키마를 준수하도록 기존 데이터 형태를 변경하는 과정) 문제를 해결하는데 도움이 됨
     
    > 저자의 의견
    > 상태 기반 방식보다 마이그레이션 기반 방식을 더 선호하라.

### 데이터베이스 트랜잭션 관리
* 잠재적인 모순을 피하기 위해 결정유형을 두가지로 분리
  * 업데이트할 데이터
  * 업데이트 유지 또는 롤백 여부
  
* 책임 구분을 위한 분리
  * 레포지토리 : 데이터베이스 호출이 완료되는 즉시 폐기
  * 트랜잭션 : 비즈니스 연산 동안 존재하고 연산이 끝나면 폐기
    * commit() : 트랜잭션을 성공으로 표기
    * dispose() : 트랜잭션 종료, 이전에 commit()이 호출된 경우 데이터 업데이트 저장, 아니면 전체 rollback()
    * 작업 단위로 업그레이드 할 수 있음(장점 : 업데이트 지연 - 트랜잭션 기간단축 + 데이터 혼잡도 낮춤)

* 테스트 구절 간에는 트랜잭션이나 작업 단위를 재사용하지 말라.
  * 운영 환경에서 하는 것과 다른 환경을 만들 수 있어 문제가 됨(동작 모순에 빠지지 않기위해)

### 테스트 데이터 생명 주기
공유 데이터베이스를 사용하면 통합 테스트를 서로 분리할 수 없는 문제가 생김
* 해결 방안
  * 통합 테스트를 순차적으로 실행
    > 통합 테스트를 병렬로 실행하려면 많은 노력 필요
    > 순차적으로 통합 테스트를 실행하는것이 더 실용적
    > 대안으로, 컨테이너를 사용하여 테스트를 병렬 처리할 수 있음
  * 테스트 실행 간에 남은 데이터를 제거
    * 데이터 정리 방법 (별도의 종료 단계 없이 준비 구절에 구현)
      1. 각 테스트전에 데이터베이스 백업 복원하기
      2. 테스트 종료 시점에 데이터 정리하기
      3. 데이터베이스 트랜잭션에 각 테스트를 랩핑하고 커밋하지 않기
      4. 테스트 시작 시점에 데이터 정리하기
  * 인메모리 데이터베이스 피하기
    통합 테스트를 서롤 분리하는 방법 중 하나로 인메모리 데이터베이스로 교체할 수 있다.
    * 인메모리 데이터베이스 장점
      * 테스트 데이터를 제거할 필요가 없음
      * 작업 속도 향상
      * 테스트가 실행될 때마다 인스턴스화 가능
    * 인메모리 데이터베이스 단점
      * 일반 데이터베이스와 기능적으로 일관성이 없음
      * 운영환경과 일치 하지 않음
      * 거짓 양성 or 거짓 음성이 발생하기 쉬움

### 테스트 구절에서 코드 재사용하기
> 통합 테스트가 너무 빨리 커지면 유지 보수 지표가 나빠질 수 있음
> 통합 테스트는 가능한 짧게 하되 서로 결합하거나 가독성에 영향을 주지 않는 것이 중요함
* 준비 구절에서 코드 재사용 하기
  * 비공개 팩토리 메서드 도입 
    * 팩토리 매서드는 동일한 클래스에 배치
    * 예외적으로 코드복제가 중요한 문제가 될 경우에만 별도의 헬퍼 클래스로 이동
    * 기초 클래스에는 배치x, 기초클래스는 데이터 정리와 같이 모든 테스트에서 실행해야 해야 하는 코드를 위한 클래스

* 실행 구절에서 코드 재사용 하기
  * 대리자(어떤 컨드로럴 기능을 호출해야 하는지에 대한 정보가 담긴)를 받는 메서드를 도입
  
* 검증 구절에서 코드 재사용 하기
  * 헬퍼 메서드를 이용
  * 플루언트 인터페이스 생성
    > 플루언트 인터페이스를 사용하면 코드를 읽기 쉽고 간결하게 만들 수 있으며, 자연어와 유사한 형태로 API를 사용할 수 있음

* 테스트가 데이터베이스 트랜잭션을 너무 많이 생성하는가?
  * 테스트 구절에서 코드 재사용했을 때 데이터베이스 트랜잭션 수가 증가할 수 있다.
    * 트랜잭션 수가 증가하면 테스트가 느려질 수 있다.
    * 이런 경우에는 테스트의 특징간에 절충이 필요하다.

### 데이터메이스 테스트에 대한 일반적인 질문
* 읽기 테스트를 해야하는가?
  * 쓰기 테스트와 다르게 [읽기] 작업의 버그에는 보통 해로운 문제가 없다.
  * 읽기 테스트 임계치는 쓰기 테스트 임계치보다 높아야 한다.
  * 가장 복잡하거나 중요한 읽기 작업만 테스트하고 나머지는 무시한다.
  * 읽기는 도메인 모델도 필요하지 않다.
* 리포지터리 테스트를 해야 하는가?
  * 리포지터리 테스트의 단점
    1. 높은 유지비
        레포지터리는 복잡도가 거의 없고 프로세스 외부 의존성인 데이터메이스와 통신한다. 
        -> 테스트의 유지비가 증가한다.
    2. 낮은 회귀 방지
        레포지터리는 복잡도가 낮아 회귀방지에서 일반적인 통합 테스트가 주는 이점과 겹친다.
        리포지터리가 가진 약간의 복잡도를 별도의 알고리즘으로 추출하고 해당 알고리즘 전용 테스트를 작성하는 것이 좋다.
    
