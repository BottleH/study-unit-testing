# 7. 가치있는 단위 테스트를 위한 리팩터링

### 7.1 리팩터링한 코드 식별하기
> 기반 코드를 리팩터링 하지 않고서는 테스트 스위트를 크게 개선할 수 없다.

#### 코드의 네 가지 유형
<코드의 유형을 나누는 지표>
* 복잡도 또는 도메인 유의성
  * 코드 복잡도 = 코드 내 의사 결정 지점 수로 정의 (숫자와 크기 비례)
  * 도메인 유의성 = 코드가 프로젝트의 문제 도메인에 대해 얼마나 의미있는지를 나타냄
  > 복잡한 코드와 도메인 유의성을 갖는 코드가 단위 테스트에서 가장 이로움 => 회귀 방지에 뛰어남
* 협력자 수
  * 협력자 = 가변 의존성, 프로세스 외부 의존성 등을 의미
  > 협력자의 크기와 테스트의 크기 비례함

<코드의 네가지 유형>
1. 도메인 모델과 알고리즘
    > 단위 테스트시 노력 대비 가장 이로움
    > 매우 가치있고 저렴함 (코드가 복잡하거나 중요한 로직을 수행함으로 회귀방지가 향상됨)
    > 코드에 협력자가 거의 없어서 테스트 유지비를 낮춤( = 저렴)
2. 간단한 코드
   > 테스트할 필요 없음(가치가 0에 가까움)
3. 컨트롤러
   > 포괄적인 통합 테스트의 일부로서 간단히 테스트
4. 자나치게 복잡한 코드
   > 가장 문제가 되는 코드 유형
   > 단위 테스트가 어렵지만 안하기에는 위험함
   > 지나치게 복잡한 코드를 알고리즘과 컨트롤러라는 두 부분으로 나누는것이 일반적

~~~
코드가 더 중요해지거나 복잡해질수록 협력자는 더 적어야 한다.
좋지 않은 테스트를 작성하는 것보다는 테스트를 전혀 작성하지 않는 편이 낫다.
~~~

<지나치게 복잡한 코드를 제거하는데 도움이 되는 기법>

* 험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할 하기
  * 제라드 메스자로스가 [xUnit 테스트 패턴]에서 코드 결합과 싸우는 방법 중 하나로 소개함
  * 테스트 대상 코드의 로직을 테스트 하려면 테스트가 가능한 부분을 추출해야 함
  * 험블래퍼(테스트 가능한 부분을 둘러싼 얇은 부분)는 자체적인 로직이 거의 없거나 전혀 없으므로 테스트할 필요 없음
  * 추출된 로직은 테스트하기 어려운 의존성에서 분리된 다른 클래스로 이동
* 단일 책임 원칙을 지키는 것

### 가치 있는 단위 테스트를 위한 리팩터링 하기
<고객 관리 시스템>
* 사용자 이메일이 회사 도메인에 속한 경우 해당 사용자는 직원으로 표시된다. 그렇지 않으면 고객으로 간주한다.
* 시스템은 회사의 직원 수를 추적해야 한다. 사용자 유형이 직원에서 고객으로, 또는 그 반대로 변경되면 이 숫자도 변경해야 한다.
* 이메일이 변경되면 시스템은 메시지 버스로 메시지를 보내 외부 시스템에 알려야 한다.

1 단계 : 암시적 의존성을 명시적으로 만들기
> 테스트 용이성을 개선하는 일반적인 방법은 암시적 의존성을 명시적으로 만드는 것
> 도메인 모델은 직접적으로든 간접적으로든 프로세스 외부 협력자에게 의존하지 않는 것이 훨씬 더 깔끔하다.

2 단계 : 애플리케이션 서비스 계층 도입
> 도메인 모델이 외부 시스템과 직접 통신하는 문제를 극복하려면 다른 클래스인 험블 컨트롤러로 책임을 옮겨야 한다.

3 단계 : 애플리케이션 서비스 복잡도 낮추기
> ORM 라이브러리를 이용해 재구성 로직 추출
> 도메인 모델에 원시 데이터베이스 데이터로 도메인 클래스를 인스턴스화 하는 팩토리 클래스 작성

4 단계 : 새 Company 클래스 소개