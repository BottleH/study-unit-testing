# 7. 가치있는 단위 테스트를 위한 리팩터링

### 7.1 리팩터링한 코드 식별하기
> 기반 코드를 리팩터링 하지 않고서는 테스트 스위트를 크게 개선할 수 없다.

#### 코드의 네 가지 유형
<코드의 유형을 나누는 지표>
* 복잡도 또는 도메인 유의성
  * 코드 복잡도 = 코드 내 의사 결정 지점 수로 정의 (숫자와 크기 비례)
  * 도메인 유의성 = 코드가 프로젝트의 문제 도메인에 대해 얼마나 의미있는지를 나타냄
  > 복잡한 코드와 도메인 유의성을 갖는 코드가 단위 테스트에서 가장 이로움 => 회귀 방지에 뛰어남
* 협력자 수
  * 협력자 = 가변 의존성, 프로세스 외부 의존성 등을 의미
  > 협력자의 크기와 테스트의 크기 비례함

<코드의 네가지 유형>
1. 도메인 모델과 알고리즘
    > 단위 테스트시 노력 대비 가장 이로움
    > 매우 가치있고 저렴함 (코드가 복잡하거나 중요한 로직을 수행함으로 회귀방지가 향상됨)
    > 코드에 협력자가 거의 없어서 테스트 유지비를 낮춤( = 저렴)
2. 간단한 코드
   > 테스트할 필요 없음(가치가 0에 가까움)
3. 컨트롤러
   > 포괄적인 통합 테스트의 일부로서 간단히 테스트
4. 자나치게 복잡한 코드
   > 가장 문제가 되는 코드 유형
   > 단위 테스트가 어렵지만 안하기에는 위험함
   > 지나치게 복잡한 코드를 알고리즘과 컨트롤러라는 두 부분으로 나누는것이 일반적

~~~
코드가 더 중요해지거나 복잡해질수록 협력자는 더 적어야 한다.
좋지 않은 테스트를 작성하는 것보다는 테스트를 전혀 작성하지 않는 편이 낫다.
~~~

<지나치게 복잡한 코드를 제거하는데 도움이 되는 기법>

* 험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할 하기
  * 제라드 메스자로스가 [xUnit 테스트 패턴]에서 코드 결합과 싸우는 방법 중 하나로 소개함
  * 테스트 대상 코드의 로직을 테스트 하려면 테스트가 가능한 부분을 추출해야 함
  * 험블래퍼(테스트 가능한 부분을 둘러싼 얇은 부분)는 자체적인 로직이 거의 없거나 전혀 없으므로 테스트할 필요 없음
  * 추출된 로직은 테스트하기 어려운 의존성에서 분리된 다른 클래스로 이동
* 단일 책임 원칙을 지키는 것

### 7.2 가치 있는 단위 테스트를 위한 리팩터링 하기
<고객 관리 시스템>
* 사용자 이메일이 회사 도메인에 속한 경우 해당 사용자는 직원으로 표시된다. 그렇지 않으면 고객으로 간주한다.
* 시스템은 회사의 직원 수를 추적해야 한다. 사용자 유형이 직원에서 고객으로, 또는 그 반대로 변경되면 이 숫자도 변경해야 한다.
* 이메일이 변경되면 시스템은 메시지 버스로 메시지를 보내 외부 시스템에 알려야 한다.

1 단계 : 암시적 의존성을 명시적으로 만들기
> 테스트 용이성을 개선하는 일반적인 방법은 암시적 의존성을 명시적으로 만드는 것
> 도메인 모델은 직접적으로든 간접적으로든 프로세스 외부 협력자에게 의존하지 않는 것이 훨씬 더 깔끔하다.

2 단계 : 애플리케이션 서비스 계층 도입
> 도메인 모델이 외부 시스템과 직접 통신하는 문제를 극복하려면 다른 클래스인 험블 컨트롤러로 책임을 옮겨야 한다.

3 단계 : 애플리케이션 서비스 복잡도 낮추기
> ORM 라이브러리를 이용해 재구성 로직 추출
> 도메인 모델에 원시 데이터베이스 데이터로 도메인 클래스를 인스턴스화 하는 팩토리 클래스 작성

4 단계 : 새 Company 클래스 소개

### 7.3 최적의 단위 테스트 커버리지 분석
비즈니스 로직과 오케스트레이션을 완전히 분리하면 코드베이스의 어느 부분을 테스트 단위로 할지 쉽게 결정할 수 있다.

#### 복잡도와 도메인 유의성이 높음 + 협력자가 거의 없음
* 코드의 복잡도나 도메인 유의성이 높으면 회귀 방지가 뛰어고 협력자가 거의 없어 유지비도 낮다.

#### 복잡도와 도메인 유의성이 낮음 + 협력자가 거의 없음
* 단순해서 큰 노력을 들일 필요가 없고 회귀 방지가 떨어짐

#### 복잡도와 도메인 유의성이 낮음 + 협력자가 많음

### 7.4 컨트롤러에서 조건부 로직 처리
> 조건부 로직을 처리하면서 동시에 프로세스 외부 협력자 없이 도메인 계층을 유지 보수하는 것은 까다롭다.

* 비즈니스 로직과 오케스트레이션의 분리는 비즈니스 연산이 세 단계로 있을 때 가장 효과적
1. 저장소에서 데이터 검색
2. 비즈니스 로직 실행
3. 데이터를 다시 저장소에 저장

* 비즈니스 연산 중에 프로세스 외부 의존성을 참조해야하는 경우
1. 외부에 대한 모든 읽기와 쓰기는 가장자리로 밀어낸다
   1. '읽기 - 결정하기 - 실행하기' 구조를 유지하지만 성능이 저하됨
   2. 필요 없는 경우에도 컨트롤러가 프로세스 외부 의존성을 호출
   > 컨트롤러를 계속 단순하게 하고 프로세스 외부 의존성과 도메인 모델을 분리하지만, 성능이 저하된다.
2. 도메인 모델에 프로세스 외부 의존성 주입
   1. 비즈니스 로직이 헤당 의존성을 호출할 시점을 직접 결정
   > 성능을 유지하면서 컨트롤러를 단순하게 하지만, 도메인 모델의 테스트 유의성이 떨어진다.
3. 의사 결정 프로세스 단계를 더 세분화
   1. 각 단계별로 컨트롤러를 실행하도록 한다.
   > 성능과 도메인 모델 테스트 유의성에 도움을 주지만, 컨트롤러가 단순하지 않다.
   > 이러한 세부 단계를 관리하려면 컨트롤러에 의사 결정 지점이 있어야 한다.

~~~
도메인 모델 테스트 유의성: 도메인 클래스의 협력자 수와 유형에 따른 함수
컨트롤러 단순성 : 의사 결정 지점이 있는지에 따라 다름
성능 : 프로세스 외부 의존성에 대한 호출 수로 정의
~~~

* CanExecute/Execute 패턴 사용
> 컨트롤러 복잡도가 커지는 것을 완화하는 첫 번째 방법
 
비즈니스 로직이 도메인 모델에서 컨트롤러로 유출되는 것을 방지
- 컨트롤러는 프로세스를 알 필요가없다.
  - 메서드를 호출하여 연산을 수행할 수 있는지 확인만 필요
  - 메서드에 해아하는 유효성 검사가 있을 수 있지만 해당 사항은 컨트롤러로부터 캡슐화 
도메인 계층의 모든 결정을 통합할 수 있음

* 도메인 이벤트를 사용해 도메인 모델 변경 사항 추적
> 도메인 모델을 현재 상태로 만든 단계를 빼기 어려울 때
> 도메인 이벤트로 도메인 모델에서 중요한 변경 사항을 추적하고 비즈니스 연산이 완료된 후 해당 변경 사항을 프로세스 외부 의존성 호출로 변환한다.