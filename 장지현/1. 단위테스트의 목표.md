## Chapter 1. 단위 테스트의 목표

> **단위 테스트**
> :: **앱의 작은 단위(일반적으로 메서드)를 사용하여 코드의 나머지 부분에서 격리하고 예상대로 작동하는지 확인하는 테스트**
> 목표는 각 기능 단위가 예상대로 수행되므로 앱 전체에서 오류가 전파되지 않도록 하는 것
[단위 테스트 정의](https://learn.microsoft.com/ko-kr/dotnet/architecture/maui/unit-testing)

### 1.1 단위 테스트 현황
- **기존의 쟁점 포인트 :: [단위 테스트를 적용해야 하는가?]**
	- 쓰고 버리는 프로젝트가 아니라면, 늘 적용해야 함!
- **새로운 쟁점 포인트 ::  [좋은 단위 테스트를 작성하는 것은 어떤 의미인가?]**
	- 단위 테스트가 존재 함에도 불구 개발자들이 원하는결과를 얻지 못하는 경우 존재
		- 새로운 기능을 구현하는데 오래 걸림
		- 이미 구현된 기능에 새로운 버그가 지속적으로 발견
		- 단위 테스트가 제 역할을 수행하지 못함
	-> 제대로 작동하지 않는 단위 테스트의 결과

### 1.2 단위 테스트의 목표
* 목표 :: **소프트웨어 프로젝트의 <u>지속 가능한 성장</u>을 가능하게 하는것**
* 단위 테스트의 긍정적 side effect
	* 더 나은 설계
		> **단위 테스트와 코드 설계의 관계**
		> 비교적 높은 정확도로 저품질 코드(ex> 강결합 코드)를 가려낸다.
		> 코드를 단위 테스트 하기 어렵다. -> 코드 개선 반드시 필요!
		> 그러나 코드베이스를 쉽게 단위테스트 할 수 있다고 해도 반드시 코드 품질이 좋은것을 의미하지는 않음
	* <u>소프트웨어 엔트로피</u> 방지
		> **소프트웨어 엔트로피(software entropy)**
		> * 개발 속도가 빠르게 감소하는 현상
		> * 코드 무질서
		
		![테스트 유무에 따른 프로젝트 간 성장 추이의 차이](https://velog.velcdn.com/images/jkijki12/post/032394d6-c60f-4389-a673-b0656a219717/image.png)
	* 테스트가 없는 프로젝트는 시간이 지나면서 작업에 많은 시간을 투자해야한다.
		* 초반에는 발목을 잡을 것이 없어 개발 속도가 빠르다.
		* 코드베이스에서 무언가를 변경할 때마다 무질서도가 증가한다.
		* 도미노 처럼 하나의 버그를 수정하면 더 많은 버그를 양산할 수 있다.
		* 결과적으로 코드 베이스를 신뢰 할 수 없게 된다.
		* 최악의 경우 안정되게 복구하는것이 어려울 수 있다.
	
	* 테스트가 있는 프로젝트는 시간이 지남과 관계없이 개발 속도를 유지할 수 있다.
		* 테스트가 안전망 역할을 수행한다.
		* 회위에 대한 보험을 제공한다.
			= 코드 수정 후 기존 기능이 잘 동작하는지 확인하는데 도움을 제공한다.
		* 테스트 초반에 노력이 필요하다. (어쩌면 상당한 노력)
		
* 좋은 테스트와 좋지 않은 테스트를 가르는 요인
	* 단위 테스트 작성이 언제나 도움이 되지는 않는다.
		-> 잘못 작성한 테스트는 여전히 같은 결과를 낳는다.
		-> 잘못 작성된 프로젝트는 결국 침체 단계에 빠진다. 
	* 좋은 테스트
		* 소프트웨어 품질에 매우 많은 기여를 하는 테스트
		* 순가치가 높은 테스트
	* 좋지 않은 테스트
		* 잘못된 경고가 발생하는 테스트
		* 프로젝트에 도움이 되는지 여부와 관계없이 작성 자체에만 의미가 있는 테스트
		* 높은 유지보수 비용으로 인해 순가치가 0에 가까운 테스트
	* 지속가능한 프로젝트 성장을 위해서는 고품질 테스트에만 집중해햐함
	* 고춤질 테스트만이 테스트 스위트에 남을 만한 테스트 유형
### 1.3 테스트 스위트 품질 측정을 위란 커버리지 지표
	> 커버리지 지표는 테스트 스위트가 소스 코드를 얼마나 실행하는지를 백분율로 나타낸다.
	> 커버리지 지표는 중요한 피드백을 주더라도 테스트 스위트 품질을 효과적으로 측정하는 데 사용될 수 없다.
	> **커버리지 지표는 괜찮은 부정 지표이지만 좋지 않은 긍정 지표이다.**
	
* 코드 커버리지
	> 코드 커버리지 = 제품 코드 라인수 / 전체 라인 수
* 분기 커버리지
	> 분기 커버리지 = 통과 분기 수 / 전체 분기 수 
* 커버리지 지표에 관한 문제점
	* 테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다.
		> 단지 코드 경로를 통과하는 것을 테스트 하는 것이 아니라면, 반드시 테스트 대상 시스템이 낸 결과가 정확히 예상하는 결과인지 확인 해야 한다.
		-> 커버리지 지표가 의미있으려면, 모든 측정 지표를 검증해야 한다.
	* 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.
		> 모든 커버리지 지표가 테스트 대상 시스템이 메서드를 호출할 때 외부 라이브러리가 통과하는 코드 경로를 고려하지 않은다.
		> 수 많은 예외 상황에 빠질 수 있지만 테스트에서 모든 예외상황을 다루는지 확인할 방법이 없다.
* 특정 커버리지 숫자를 목표로 여겨서는 안된다.
	* 특정 커버리지 숫자를 목표로 삼는다면, 사람들은 중요한 것을 테스트하는 데 집중하는 대신 인공적인 목표를 달성하기 위한 방법을 찾기 시작한다.

### 1.4 무엇이 성공적인 테스트 스위트를 만드는가?
* 성공적인 테스트 스위트
	* 개발 주기에 통합
	* 코드 베이스에서 가장 중요한 부분만을 대상으로 함
	* 최소한의 유지비로 최대의 가치를 끌어냄
