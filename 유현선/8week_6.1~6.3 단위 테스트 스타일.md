# 6. 단위 테스트 스타일 

## 6.1 단위 테스트의 3 가지 스타일

### 6.1.1 출력 기반 테스트 정의
- 테스트 대상 시스템에 입력을 넣고 생성되는 출력을 점검하는 방식
- 함수형 : 부작용 없는 코드 선호를 강조하는 프로그램 방식(함수형 프로그래밍)

### 6.1.2 상태 기반 스타일 정의
- 작업이 완료된 후 시스템 상태를 확인하는 것 
- 상태 : SUT, 협력자 중 하나, 프로세스 외부 의존성(DB, 파일시스템 등)의 상태

### 6.1.3 통신 기반 스타일 정의 
- Mock을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증


---
## 6.2 단위 테스트 스타일 비교 

### 6.2.1 회귀 방지와 피드백 속도 지표로 스타일 비교하기
- 테스트 중에 실행되는 코드의 양 / 코드 복잡도 / 도메인 유의성
- 스타일 간의 차이는 거의 없음

### 6.2.2 리팩토링 내성 지표로 스타일 비교하기 
- 출력 기반 테스트 : 거짓 양성 방지가 가장 우수
- 상태 기반 테스트 : 일반적으로 거짓 양성이 되기 쉽다
  - 구현 세부 사항과 결합할 가능성이 높음
- 통신 기반 테스트 : 허위 경보에 가장 취약


캡슐화를 잘 지키고 테스트를 식별할 수 있는 동작에만 결합하면 거짓 양성을 최소로 줄일 수 있다.  

### 6.2.3 유지 보수성 지표로 스타일 비교하기
유지 보수성
- 단위 테스트의 유지비를 측정
- 정의 
  - 테스트를 이해하기 얼마나 어려운가? (테스트 크기에 대한 함수)
  - 테스트를 실행하기 얼마나 어려운가? (프로세스 외부 의존성)


- 출력 기반 테스트 : 거의 항상 짧고 간결 > 유지 보수하기 용이
- 상태 기반 테스트 : 상태 검증이 출력 검증보다 더 많은 공간을 차지 > 유지보수가 쉽지 않음  
  - 파훼하기 위한 기법(헬퍼 메서드 사용, 값 객체로 클래스 변환)이 있지만 가끔만 적용할 수 있고 잘못 사용 시 코드 오염으로 이어짐 
- 통신 기반 테스트  : 유지보수가 가장 어려움 


### 6.2.4 스타일 비교하기 : 결론
출력 기반 테스트
- 출력 기반 테스트가 가장 좋지만 (유지보수와 리팩터링 내성에 강함) 사용하기가 쉽지 않음
- 함수형으로 작성된 코드에만 적용할 수 있음 (그러나 대부분의 객체지향 프로그래밍 언어에는 해당하지 않음)
- 코드를 순수 함수로 만들면 상태 기반 테스트나 통신 기반 테스트 대신 출력 기반 테스트가 가능해진다.

---
## 6.3 함수형 아키텍처 이해

### 6.3.1 함수형 프로그래밍이란? 
- 수학적 함수(순수 함수)를 사용한 프로그래밍 
- 수학적 함수 : 숨은 입출력이 없는 함수(메서드). 호출 횟수에 상관없이 주어진 입력에 대해 동일한 출력을 생성
- 모든 입출력은 메서드 이름, 인수, 반환 타입으로 구성된 메서드 시그니처에 명시 

```java
public class Ex {
    public double CalculateDiscount(Product[] products) {
        double discount = products.size() * 0.01;
        return Math.min(discount, 0.2);
    }
}
```

입출력을 명시한 수학적 함수 : 테스트가 짧고 간결하며 이해하고 유지 보수가 쉬움

숨은 입출력 : 코드를 테스트하기 힘들게 함
- 부작용 : 메서드 시그니처에 표시되지 않은 출력
- 예외
- 내외부 상태에 대한 참조


### 6.3.2 함수형 아키텍처란? 
- 함수형 프로그래밍의 목표 : 비지니스 로직을 처리하는 코드와 부작용을 일으키는 코드를 분리하는 것
- 부작용을 비즈니스 연산 끝으로 몰아서 비즈니스 로직을 부작용과 분리한다


- 결정을 내리는 코드 = 함수형 코어(불변 코어) : 이 코드는 부작용이 필요 없기 때문에 수학적 함수를 사용해 작성
- 해당 결정에 따라 작용하는 코드 = 가변 셸 : 이 코드는 수학적 함수에 의해 이뤄진 모든 결정을 데이터베이스의 변경이나 메세지 버스로 전송된 메세지와 같이 가지석인 부분으로 변환


- 가변 셸은 모든 입력을 수집
- 함수형 코어는 결정을 생성
- 셸은 결정을 부작용으로 변환 

객체지향 프로그래밍은 작동 부분을 캡슐화해 코드를 이해할 수 있게 한다. 함수형 프로그래밍은 작동 부분을 최소화해 코드를 이해할 수 있게 한다.

### 6.3.3 함수형 아키텍처와 육각형 아키텍처 비교 
유사점 (함수형 vs 육각형)
- 결정과 실행을 분리 vs 도메인 계층과 어플리케이션 서비스 계층을 분리
- 의존성 간의 단방향 흐름 : 불변 코어는 가변 셸에 의존하지 않음 vs 도메인 계층 내 클래슨느 서로에게만 의존 

차이점 : 부작용에 대한 처리
- 함수형 아키텍처 : 모든 부작용을 불변 코어에서 비즈니스 연산 가장자리로 밀어내고, 가변 셸이 처리
- 육각형 아키텍처 : 도메인 계층에 제한하는 한, 도메인 계층으로 인한 부작용도 문제 없음