## 5.3 mock 과 테스트 취약성 간의 관계

### 5.3.1 육각형 아키텍처 정의 

1) 도메인 계층과 애플리케이션 서비스 계층 간의 관심사 분리 
2) 애플리케이션 내부 통신
3) 애플리케이션 간의 통신


### 5.3.2 시스템 내부 통신과 시스템 간 통신 

- 시스템 내부 통신 : 애플리케이션 내 클래스 간의 통신 / 구현 세부 사항
  - mock 을 사용할 경우 - 테스트가 구현 세부 사항과 결합 -> 리팩토링 내성 지표가 미흡해짐
- 시스템 간 통신 : 애플리케이션이 다른 애플리케이션과 통신하는 것
  - mock 을 사용하여 시스템과 외부 시스템 간의 통신 패턴을 확인하는데 유리하다


## 5.4 단위 테스트의 고전파와 런던파 재고 
> 런던파 : 목 추종자(mockist)
>   - 격리 주체 : 단위
>   - 단위의 크기 : 단일 클래스
>   - 테스트 대역 사용 대상 : 불변 의존성 외 모든 의존성
>
> 고전파 : Detroit, 단위 테스트에 대한 고전주의적 접근법
>   - 격리 주체 : 단위 테스트
>   - 단위의 크기 : 단일 클래스 또는 클래스 세트
>   - 테스트 대역 사용 대상 : 공유 의존성 


- 런던파의 치명적인 문제점 : mock 을 남발하여 구현 세부 사항에 결합돼 테스트에 리팩토링 내성이 없어짐 
- 고전파는 테스트 간에 공유하는 의존성만 교체하려고 한다는 점에서 런던파보다는 리팩토링 내성 문제에 유리함 

### 5.4.1 모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다
- 공유 의존성 : 테스트 간에 공유하는 의존성 (제품 코드 X)
- 프로세스 외부 의존성 : 프로그램의 실행 프로세스 외에 다른 프로세르르 점유하는 의존성 (ex DB, SMTP 등)
- 비공개 의존성 : 공유하지 않는 모든 의존성 

완전히 통제권을 가진 프로세스 외부 의존성에 mock 을 사용하면 깨지기 쉬운 테스트로 이어짐 -> 데이터베이스와 어플리케이션은 하나의 시스템으로 취급해야 함  



### 5.4.2 목을 사용한 동작 검증
 mock 은 어플리케이션의 경계를 넘나드는 상호 작용을 검증할 때와 이러한 상호 작용의 부작용이 외부 환경에서 보일 때만 동작과 관련이 있음
 