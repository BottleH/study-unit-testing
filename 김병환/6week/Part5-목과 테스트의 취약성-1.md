# 📚 5장 목과 테스트의 취약성

목과 테스트 취약성 사이에는 깊고 불가피한 관련이 있다.

## 📖 5.1 목과 스텁 구분

___

### 🔖 5.1.1 테스트 대역 유형

#### 테스트 대역

- 모든 유형의 비운영용 가짜 의존성을 설명하는 포괄적인 용어
- 스턴트 대역에서 유래됨
- 테스트를 편리하게 하는 것
- Mock
  - 외부로 나가는 상호 작용(SUT가 상태를 변경하기 위한 의존성 호출)을 모방하고 검사하는 데 도움이 됨.
  - *스파이*는 수동으로 작성하는 직접 작성한 목이다.
  - *목*은 목 프레임워크의 도움을 받아 생성된다.
- Stub
  - 내부로 들어오는 상호 작용(SUT가 입력 데이터를 얻기 위한 의존성을 호출)을 모방하는 데 도움이 됨.
  - *더미*는 단순하고 하드코딩된 값이고, 최종 결과를 만드는 데 영향을 주지 않는다.
  - *스텁*은 시나리오마다 다른 값을 반환하게끔 구성할 수 있도록 필요한 것을 완전히 다 갖춘 의존성이다.
  - *페이크*는 아직 존재하지 않는 의존성을 대체하고자 구현한다.

> 목은 SUT와 관련 의존성 간의 상호 작용을 모방하고 검사하는 반면, 스텁은 모방만 한다.

### 🔖 5.1.2 도구로서의 목과 테스트 대역으로서의 목

도구로서의 목을 상요해 목과 스텁, 두 가지의 테스트 대역을 생성할 수 있기 때문에 도구로서의 목과 테스트 대역으로서의 목을 혼동하지 않는 것이 중요하다.

### 🔖 5.1.3 스텁으로 상호 작용을 검증하지 말라

스텁과의 상호 작용을 검증하는 것은 취약한 테스트를 야기하는 일반적인 안티 패턴이다.

- SUT에서 스텁으로의 호출은 SUT가 생성하는 최종 결과가 아니다.
- 최종결과가 아닌 사항을 검증하는 이러한 관행을 과잉 명세라고 부른다.

### 🔖 5.1.4 목과 스텁 함께 쓰기

테스트 대역이 목이면서 스텁인 경우, 목이라고 부르지 스텁이라고 부르지는 않는다. 이름을 하나 골라야 하기도 하고, 목이라는 사실이 스텁이라는 사실보다 더 중요하기 때문이다.

### 🔖 5.1.5 목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?

목과 스텁의 개념은 CQS(명령 조회 분리) 원칙과 관련되어 있다.

- [CQS와 CQRS](https://cqrs.wordpress.com/documents/cqrs-introduction/)
- 목
  - 명령
  - 부작용(객체 상태 변경 등)을 일으키고, 어떤 값도 반환하지 않는 메서드
- 스텁
  - 조회
  - 부작용이 없고, 값을 반환

항상 CQS 원칙을 따를 수 있는 것은 아니지만 가능할 때마다 따르는 것이 좋다.

## 📖 5.2 식별할 수 있는 동작과 구현 세부 사항

___

### 🔖 5.2.1 식별할 수 있는 동작은 공개 API와 다르다

모든 제품코드는 다음과 같이 분류할 수 있다.

- 공개 API ↔️ 비공개 API
  - Java의 경우 접근제한자로 구분 가능
- 식별할 수 있는 동작 ↔️ 구현 세부사항
  - 식별할 수 있는 동작의 경우 클라이언트가 목표를 달성하는 데 도움이 되는 연산과 상태 노출
  - 구현 세부사항은 위의 두 가지 중 아무것도 하지 않는다.

이상적으로 시스템의 공개 API는 식별할 수 있는 동작과 일치해야 하며, 모든 구현 세부사항은 클라이언트 눈에 보이지 않아야 한다.

### 🔖 5.2.2 구현 세부 사항 유출: 연산의 예

```java
public class User {

    public String Name;

    public String normalizeName(String name) {
        String result = (StringUtils.hasText(name) ? name : "").trim();

        if (result.length() > 50) {
            return result.substring(0, 50);
        }
        return result;
    }
}

public class UserController {

    public void renameUser(String userId, String newName) {
        User user = new User(userId);

        String normalizeName = user.normalizeName(newName);
        user.setName(normalizeName);
    }
}
```

위 코드의 문제점은 클라이언트의 목표에 도움이 되지 않는 작업이 노출되는 것에 있다. 즉, 불변 속성을 만족시켜야 한다.

### 🔖 5.2.3 잘 설계된 API와 캡슐화

장기적으로 코드베이스 유지 보수에서는 캡슐화가 중요하다.

- 복잡도 때문
- 캡슐화는 궁극적으로 단위 테스트와 동일한 목표를 달성한다.

> 구현 세부 사항을 숨기면 클라이언트의 시야에서 클래스 내부를 가릴 수 있기 때문에 내부를 손상시킬 위험이 적다.
>
> 데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다.

### 🔖 5.2.4 구현 세부 사항 유출: 상태의 예

||식별할 수 있는 동작|구현 세부 사항
|:---:|:---:|:---:
|공개|좋음|나쁨
|비공개|해당 없음|좋음
