# 📚 8장 통합 테스트를 하는 이유

## 📖 8.5 통합 테스트 모범 사례

___

1. 도메인 모델 경계 명시하기
2. 애플리케이션 내 계층 줄이기
3. 순환 의존성 제거하기

### 🔖 8.5.1 도메인 모델 경계 명시하기

항상 도메인 모델을 코드베이스에서 명시적이고 잘 알려진 위치에 두도록 하라.

- 도메인 모델에 명시적 경계를 지정하면 코드의 해당 부분을 더 잘 보여주고 더 잘 설명할 수 있다.
- 이러한 경계는 별도의 어셈블리 또는 네임스페이스 형태를 취할 수 있다.

### 🔖 8.5.2 계층 수 줄이기

애플리케이션에 추상 계층이 너무 많으면 코드베이스를 탐색하기 어렵고 아주 간단한 연산이라 해도 숨은 로직을 이해하기가 어려워진다.

- 간접 계층은 코드를 추론하는 데 부정적인 영향을 미친다.
- 가능한 한 간접 계층을 적게 사용하라.
  - 대부분의 백엔드 시스템에서는 **도메인 모델, 애플리케이션 서비스 계층(컨트롤러), 인프라 계층**만 활용하면 된다.

### 🔖 8.5.3 순환 의존성 제거하기

> 순환 의존성은 둘 이상의 클래스가 제대로 작동하고자 직간접적으로 서로 의존하는 것을 말한다.
>
> 대표적으로 콜백(callback)이 있다.

- 순환 의존성은 코드를 읽고 이해하려고 할 때 알아야 할 것이 많아서 큰 부담이 된다.
  - 해결책을 찾기 위한 출발점이 명확하지 않기 때문
- 순환의존성은 테스트를 방해한다.
- 인터페이스 사용은 순환 의존성의 뭄ㄴ제만 가린다.
  - 컴파일 타임에서만 제거 가능하고, 런타임에는 순환참조가 있다.

### 🔖 8.5.4 테스트에서 다중 실행 구절 사용

테스트에서 두 개 이상의 준비나 실행 또는 검증 구절을 두는 것은 code smell에 해당한다.

- 테스트가 여러 가지 동작 단위를 확인해서 테스트의 유지 보수성을 저해한다는 신호

예를 들어, 하나의 통합 테스트에서 두가지 유스케이스를 모두 확인하려고 하면

준비 -> 실행 -> 검증 -> 실행 -> 검증

의 구조를 가진다.

- 사용자의 상태가 자연스럽게 흐르기 때문에 설득력이 있고, 첫 번째 실행은 두 번째 실행의 준비 단계 역햘을 할 수 있다.
- 이러한 테스트가 초점을 잃고 순식간에 너무 커질 수 있다
- 각 실행을 고유의 테스트로 추출해 테스트를 나누는 것이 장기적으로 유리하다.
  - 예외: 원하는 상태로 만들기 어려운 프로세스 외부 의존성으로 작동하는 테스트는 하나로 묶어서 상호 작용 횟수를 줄이는 것이 유리함.

## 📖 8.6 로깅 기능을 테스트하는 방법

- 로깅을 조금이라도 테스트해야 하는가?
- 만약 그렇다면 어떻게 테스트해야 하는가?
- 로깅이 얼마나 많으면 충분한가?
- 로거 인스턴스를 어떻게 전달할까?

### 🔖 8.6.1 로깅을 테스트해야 하는가?

- 로깅은 횡단 기능이다.
- 로깅이 개발자 이외의 다른 사람이 보는 경우라면, 로깅은 식별할 수 있는 동작이므로 반드시 테스트해야 한다.
- 로깅이 개발자만 본다면, 구현 세부 사항이므로 테스트해서는 안 된다.
- 지원 로깅: 지원 담당자나 시스템 관리자가 추적할 수 있는 메시지를 생성
- 진단 로깅: 개발자가 애플리케이션 내부 상황을 파악할 수 있도록 돕는다.

### 🔖 8.6.2 로깅을 어떻게 테스트해야 하는가?

로깅은 프로세스 외부 의존성이 있기 때문에 테스트에 관한 한 프로세스 외부 의존성에 영향을 주는 다른 기능과 동일한 규칙이 적용된다.

- 애플리케이션과 로그 저장소 간의 상호 작용을 검증하려면 목을 써야 한다.

구조화된 로깅은 로그 데이터 캡처와 렌더링을 분리하는 로깅 기술이다.

- 전통적인 로깅
  - 간단한 테스트로 작동
  - 먼저 문자열을 만든 다음 로그 저장소에 해당 문자열을 기록
  - 로그 파일을 분석하기 어려움
  - `log.info("user id is " + 12");`
- 구조화된 로깅
  - 로그 저장소에 구조가 있음.
  - 메시지 템플릿의 해시(공간 효율성을 위해 메시지를 색인 저장소에 저장)를 계산하고 해당 해시를 입력 매개변수와 결합해 캡처한 데이터 세트를 형성
  - 캡처한 데이터를 Json, csv 파일로 렌더링하도록 로깅 라이브러리를 설정할 수 있음
  - `log.info("user id is {} ", 12");`

### 🔖 8.6.3 로깅이 얼마나 많으면 충분한가?

진단 로깅을 과도하게 사용하지 않는 것이 중요

- 과도한 로깅은 코드를 혼란스럽게 한다.
- 신호를 최대한으로 늘리고 잡음을 최소한으로 줄여라.
- 도메인 모델에서는 진단 로깅을 절대 사용하지 않도록 하라.

### 🔖 8.6.4 로거 인스턴스를 어떻게 전달하는가?

정적 메서드를 사용하는 방법이 있음

- ambient context라고도 함.
- 의존성이 숨어있고 변경하기가 어렵다.
- 테스트가 더 어려워진다.
- 코드의 잠재적인 문제를 가린다.

클래스 생성자를 통해 명시적으로 주입하는 방법이 있음

## 📖 8.7 결론

식별할 수 있는 동작인지, 구현 세부 사항인지 구분하여 프로세스 외부 의존성과의 통신을 살펴보자.

- 개발자가 아닌 사람이 로그를 볼 수 있으면 로깅 기능을 목으로 처리
- 개발자만 로그를 본다면 테스트를 하지 말라
