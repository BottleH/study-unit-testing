# 📚 6장 단위 테스트 스타일

## 📖 6.1 단위 테스트의 세 가지 스타일

___

단위 테스트는 세가지 스타일이 있다.

- 출력 기반 테스트
- 상태 기반 테스트
- 통신 기반 테스트

### 🔖 6.1.1 출력 기반 테스트 정의

SUT에 입력을 넣고 생성되는 출력을 점검하는 방식. 전역 상태나 내부 상태를 변경하지 않는 코드에만 적용되므로 반환 값만 검증하면 된다.

출력 기반 단위 테스트 스타일은 함수형이라고도 한다.

### 🔖 6.1.2 상태 기반 스타일의 정의

작업이 완료된 후 시스템 상태를 확인하는 것이다.

- 상태: SUT나 협력자 중 하나, 데이터베이스나 파일 시스템 등과 같은 프로세스 외부 의존성의 상태

### 🔖 6.1.3 통신 기반 스타일의 정의

목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증

> 고전파는 상태 기반 스타일을 선호하고, 런던파는 통신 기반 스타일을 선호한다. 두 분파는 출력 기반 테스트를 사용한다.

## 📖 6.2 단위 테스트 스타일 비교

___

### 🔖 6.2.1 회귀 방지와 피드백 속도 지표로 스타일 비교하기

회귀방지 지표는 특정 스타일에 따라 달라지지 않고, 다음 세 가지 특성으로 결정된다.

- 테스트 중에 실행되는 코드의 양
- 코드 복잡도
- 도메인 유의성

테스트 스타일과 테스트 피드백 속도 사이에는 상관관계가 거의 없다. 테스트가 프로세스 외부 의존성과 떨어져 단위 테스트 영역에 있는 한, 모든 스타일은 테스트 실행 속도가 거의 동일하다.

### 🔖 6.2.2 리팩터링 내성 지표로 스타일 비교하기

리팩터링 내성은 리팩터링 중에 발생하는 거짓 양성 수에 대한 척도다.

- 출력 기반 테스트
  - 테스트가 테스트 대상 메서드에만 결합되므로 거짓 양성 방지가 가장 우수하다.
- 상태 기반 테스트
  - 거짓 양성이 되기 쉽다.
  - 테스트와 제품 코드 간의 결합도가 클수록 유출되는 구현 세부 사항에 테스트가 얽매일 가능성이 커진다.
- 통신 기반 테스트
  - 허위 경보(거짓 양성)에 가장 취약하다.

### 🔖 6.2.3 유지 보수성 지표로 스타일 비교하기

유지 보수성은 다음 두 가지 특성으로 정의한다.

1. 테스트를 이해하기 얼마나 어려운가?
2. 테스트를 실행하기 얼마나 어려운가?

- 출력 기반 테스트
  - 가장 유지 보수하기 용이하다.
  - 프로세스 외부 의존성을 다루지 않기 때문
- 상태 기반 테스트
  - 출력 기반 테스트에 비해 유지 보수가 쉽지 않다.
  - 공간을 더 많이 차지 하기 때문.
- 통신 기반 테스트
  - 가장 유지 보수하기 어렵다.
  - 테스트 대역과 상호 작용 검증을 설정해야 하며, 공간을 많이 차지 하기 때문
  - mock chain이 있을 때, 더욱 유지 보수하기 어려워진다.

### 🔖 6.2.4 스타일 비교하기: 결론

||출력 기반|상태 기반|통신 기반
|:---:|:---:|:---:|:---:
|리팩터링 내성을 지키기 위해 필요한 노력|낮음|중간|중간
|유지비|낮음|중간|높음

출력 기반 테스트를 선호해야 한다.

## 📖 6.3 함수형 아키텍처 이해

___

### 🔖 6.3.1 함수형 프로그래밍이란?

함수형 프로그래밍은 수학적 함수(숨은 입출력이 없는 함수)를 사용한 프로그래밍

#### 수학적 함수

- 수학적 함수의 모든 입출력은 메서드 이름, 인수, 반환 타입으로 구성된 메서드 시그니처에 명시
- 수학적 함수는 호출 횟수에 상관없이 주어진 입력에 대해 동일한 출력 생성
- 입출력을 명시한 수학적 함수는 이에 따르는 테스트가 짧고 간결하며 이해하고 유지 보수하기 쉬우므로 테스트하기가 매우 쉽다.
  - 유지 보수성⬆️, 거짓 양성 빈도⬇️
- 숨은 입출력은 테스트하기 힘들고, 가돋성도 떨어진다.
  - 부작용: 메서드 시그니처에 표시되지 않은 출력
  - 예외: 메서드 시그니처에 설정된 계약을 우회하는 경로를 만듦
  - 내외부 상태에 대한 참조: 메서드 시그니처에 없는 실행흐름에 대한 입력

### 🔖 6.3.2 함수형 아키텍처란?

함수형 프로그래밍의 목표: 부작용을 완전히 제거하는 것이 아니라 비즈니스 로직을 처리하는 코드와 부작용을 일으키는 코드를 분리

- 결정을 내리는 코드
  - 부작용이 필요 없음
  - 함수형 코어(불변 코어)
- 해당 결정에 따라 작용하는 코드
  - 수학적 함수에 의해 이뤄진 모든 결정을 데이터베이스의 변경이나 메시지 버스로 전송된 메시지와 같이 가시적인 부분으로 변환
  - 가변 셸

#### 함수형 코어와 가변 셸의 협력

- 가변 셸은 모든 입력을 수집
- 함수형 코어는 결정을 생성
- 셸은 결정을 부작용으로 변환

#### 캡슐화와 불변성

캡슐화와 같이, 함수형 아키텍처와 불변성은 소프트웨어 프로젝트의 지속적인 성장을 가능하게 하는 것이 목표이다.

> 객체지향 프로그래밍은 작동 부분을 캡슐화해 코드를 이해할 수 있게 한다. 함수형 프로그래밍은 작동 부분을 최소화해 코드를 이해할 수 있게 한다.

### 🔖 6.3.3 함수형 아키텍처와 육각형 아키텍처 비교

#### 공통점

- **관심사 분리** 기반
- 의존성 간의 단방향 흐름
  - 육각형 아키텍처: 도메인 계층 내 클래스는 서로에게만 의존해야 함.
  - 함수형 아키텍처: 불변 코어는 가변 셸에 의존하지 않음.

#### 차이점

- 부작용에 대한 처리
  - 함수형 아키텍처: 모든 부작용을 불변 코어에서 비즈니스 연산 가장자리로 밀어내어 가변 셸이 처리
  - 육각형 아키텍처: 도메인 계층에 제한하는 한, 부작용은 문제없음.

> 함수형 아키텍처는 육각형 아키텍처의 하위 집합이다.