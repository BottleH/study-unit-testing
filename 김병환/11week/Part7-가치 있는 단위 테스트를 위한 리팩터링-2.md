# 📚 7장 가치 있는 단위 테스트를 위한 리팩터링

## 📖 7.3 최적의 단위 테스트 커버리지 분석

___

샘플 프로젝트를 험블 객체 패턴으로 리팩터링한 후의 코드 유형

||협력자가 거의 없음|협력자가 많음|
|------|----------------|----------|
|복잡도와 도메인 유의성이 높음|User의 ChangeEmail(newEmail, company), Company의 ChangeNumberOfEmployees(delta)와 IsEmailCorporate(email), CompanyFactory의 Create(data)||
|복잡도와 도메인 유의성이 낮음|User와 Company의 생성자|UserController의 ChangeEmail(userId, newMail)|

### 🔖 7.3.1 도메인 계층과 유틸리티 코드 테스트하기

위 표의 좌측 상단 테스트 메서드는 비용 편익 측면에서 최상의 결과를 가져다준다.

- 코드의 복잡도나 도메인 유의성이 높으면 회귀 방지가 뛰어나고 협력자가 거의 없어 유지비도 가장 낮다.

### 🔖 7.3.2 나머지 세 사분면에 대한 코드 테스트하기

1. 복잡도가 낮고 협력자가 거의 없는 코드(User와 Company의 생성자)는 단순해서 노력을 들일 필요가 없으며, 테스트는 회귀 방지가 떨어질 것이다.
2. 복잡도가 높고 협력자가 많은 모든 코드를 리팩터링으로 제거(우측 상단 사분면)했으므로 테스트할 것이 없다.
3. UserController(우측 하단 사분면)에 대해서는 7.3.3에서 살펴본다.

### 🔖 7.3.3 전제 조건을 테스트해야 하는가?

전제 조건에 대한 테스트가 테스트 스위트에 있을 만큼 충분히 가치가 있는가?

- 일반적으로 권장하는 지침은 도메인 유의성이 있는 모든 전제 조건을 테스트하는 것
  - 도메인 유의성이 없는 전제조건은 테스트하지 마라

## 📖 7.4 컨트롤러에서 조건부 로직 처리

___

비즈니스 로직과 오케스트레이션의 분리는 비즈니스 연산이 세 단계로 있을 때 가장 효과적이다.

- 저장소에서 데이터 검색
- 비즈니스 로직 실행
- 데이터를 다시 저장소에 저장(아래 그림 참고)

![7-10](./img/7-10.png)

의사 결정 프로세스의 중간 결과를 기반으로 프로세스 외부 의존성에서 추가 데이터를 조회해야 할 수도 있다.(아래 그림 참고)

![7-11](./img/7-11.png)

이러한 상황에서는 세 가지 방법이 있다.

- 외부에 대한 모든 읽기와 쓰기를 비즈니스 연산 가장자리로 밀어내기
  - 컨트롤러 단순성⬆️
  - 도메인 모델 테스트 유의성⬆️
  - 성능⬇️
- 도메인 모델에 프로세스 외부 의존성 주입하기
  - 성능 유지
  - 컨트롤러 단순성⬆️
  - 도메인 모델 테스트 유의성⬇️
- 의사 결정 프로세스 단계를 더 세분화하기
  - 성능⬆️
  - 도메인 모델 테스트 유의성⬆️
  - 컨트롤러 단순성⬇️

위와 같이 모든 특성을 충족하는 해법은 없다. 따라서 세 가지 중 두 가지를 선택해야 한다.

성능과 유지보수성은 실제 프로젝트에서 매우 중요하므로, 의사 결정 프로세스 단계를 더 세분화하기를 선택하는 것이 좋다. 다만, 컨트롤러가 너무 복잡해지기 때문에 이 문제를 완화해야 한다.

### 🔖 7.4.1 CanExecute/Execute 패턴 사용

컨트롤러가 복잡도가 커지는 것을 완화하는 첫 번째 방법은 CanExecute/Execute 패턴을 사용하는 것이다.

- 비즈니스 로직이 도메인 모델에서 컨트롤러로 유출되는 것을 방지하는 것

이메일은 사용자가 확인할 때까지만 변경할 수 있다. 사용자가 확인한 후에 이메일을 변경하려고 하면 오류메시지가 표시된다.

확인할 위치를 정하는 데 두 가지 옵션이 있다.
첫 번째로, User의 ChangeEmail Method에 넣을 수 있다.

```java
public String changeEmail(String newEmail, Company company) {

    if (isEmailConfirmed) {
        return "Can't change a confirmed email";
    }

    /* 메서드의 나머지 부분 */
}
```

- 이 메서드의 툴력에 따라 컨트롤러는 오류를 반환하거나 필요한 모든 부작용을 낼 수 있다.
- 컨트롤러가 의사결정을 하지 않지만, 성능 저하
  - 무조건 DB에서 검색
- 모든 외부 읽기와 쓰기를 비즈니스 연산 끝으로 밀어냄

두 번재로, `isEmailConfirmed`를 User에서 Controller로 옮기는 것이다.

```java
    // 컨트롤러
    if (user.isEmailConfirmed) {
        return "Can't change a confirmed email";
    }
}
```

- 성능은 그대로 유지
  - 무조건 DB 조회하지 않음
- 의사 결정 프로세스는 두 부분으로 나뉨
  - 이메일 변경 진행 여부(Controller에서 수행)
  - 변경 시 해야 할 일(User에서 수행)
- 도메인 모델의 **캡슐화가 떨어져서** 비즈니스 로직과 오케스트레이션 간의 분리가 방해되고 지나치게 복잡한 위험 영역에 더 가까워짐
  - 이를 방지하려면 CanExecute/Execute 패턴을 따르게끔 수정해야 함

```java
public String canChangeEmail() {

    if (emailConfirmed) {
        return "Can't change a confirmed email";
    }
    return null;
}

public void changeEmail(String newEmail, Company company) {

    Preconditions.checkArgument(canChangeEmail() == null);

    /* 메서드의 나머지 부분 */
}
```

- 컨트롤러는 더 이상 이메일 변경 프로세스를 알 필요가 없다.
- `changeEmail`의 전제 조건이 추가돼도 먼저 확인하지 않으면 이메일을 변경할 수 없도록 보장
- 도메인 계층의 모든 결정을 통합할 수 있음

### 🔖 7.4.2 도메인 이벤트를 사용해 도메인 모델 변경 사항 추적

도메인 모델을 현재 상태로 만든 단계를 빼기 어려울 때가 있다. 애플리케이션에서 무슨 일이 일어나는지 외부 시스템에 알려야 하기 때문에 이러한 단계들을 아는 것이 중요할 수도 있다.

도메인 모델에서 중요한 변경 사항을 추적하고 비즈니스 연산이 완료된 후 해당 변경 사항을 프로세스 외부 의존성 호출로 변환

- 도메인 이벤트로 이러한 추적을 구현할 수 있다.

> 도메인 이벤트는 이미 일어난 일들을 나타내기 때문에 항상 과거 시제로 명명

도메인 이벤트는 컨트롤러에서 의사 결정 책임을 제거하고 해당 책임을 도메인 모델에 적용함으로써 외부 시스템과의 통신에 대한 단위 테스트를 간결하게 한다.

## 📖 7.5 결론

> 추상화할 것을 테스트하기보다 추상화를 테스트하는 것이 더 쉽다.
> 즉, 추상화 대상이 되는 실제 구현체(메시지 버스, 데이터베이스, 파일 시스템 등)로 테스트하는 것보다 해당 구현체를 참조하는 추상화된 인터페이스로 테스트하는 것이 더 쉽다.

도메인 이벤트와 CanExecute/Execute 패턴을 사용해 도메인 모델에 모든 의사 결정을 잘 담을 수 있었지만, 항상 그렇게 할 수는 없다.

- 비즈니스 로직 파편화가 불가피한 상황들이 있다.

메서드가 클래스의 식별할 수 있는 동작인지 여부는 클라이언트가 누구인지와 클라이언트의 목표가 무엇인지에 달려 있다. 식별할 수 있는 동작이 되려면 메서드는 다음 두 가지 중 하나를 충족해야 한다.

- 클라이언트 목표 중 하나에 직접적인 연관이 있음
- 외부 애플리케이션에서 볼 수 있는 프로세스 외부 의존성에서 부작용이 발생함

식별할 수 있는 동작과 구현 세부 사항을 양파의 여러 겹으로 생각하자.

- 외부 계층의 관점에서 각 계층을 테스트하고, 해당 계층이 기저 계층과 어떻게 통신하는지는 무시하라.
- 이러한 계층을 하나씩 벗겨가면서 관점을 바꾸게 된다. 이전에 구현 세부 사항이었던 것이 이제는 식별할 수 있는 동작이 되며, 이는 또 다른 테스트로 다루게 된다.
