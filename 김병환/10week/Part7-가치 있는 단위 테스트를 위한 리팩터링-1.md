# 📚 7장 가치 있는 단위 테스트를 위한 리팩터링

## 📖 7.1 리팩터링할 코드 식별하기

___

기반 코드를 리팩터링하지 않고서는 테스트 스위트를 크게 개선할 수 없다.
리팩터링 방향을 설명하고자 코드를 네 가지 유형으로 분류하는 방법을 소개한다.

### 🔖 7.1.1 코드의 네 가지 유형

모든 제품 코드는 2차원으로 분류할 수 있다.

- 복잡도 또는 도메인 유의성
  - 코드 복잡도(code complexity)
    - 코드 내의 의사 결정(분기) 지점 수로 정의
    - 분기가 많을수록 복잡도 ⬆️
  - 도메인 유의성(domain significance)
    - 코드가 프로젝트의 문제 도메인에 얼마나 의미 있는지를 나타냄.
    - 도메인 계층의 모든 코드는 최종 사용자의 목표와 직접적인 연관성이 있으므로 도메인 유의성 ⬆️
  - **회귀방지**가 뛰어나기 때문에 복잡한 코드와 도메인 유의성을 갖는 코드가 단위 테스트에서 가장 이롭다.
- 협력자 수
  - 협력자: 가변 의존성, 프로세스 외부 의존성
  - 협력자가 많은 코드는 테스트 비용 ⬆️
  - 유지보수비용때문에 도메인 모델이라면 프로세스 외부 협력자를 사용하면 안된다.

코드 복잡도, 도메인 유의성 협력자 수의 조합의 네 가지 코드 유형

![7-1](./img/7-1.png)

- 도메인 모델과 알고리즘
- 간단한 코드
- 컨트롤러
- 지나치게 복잡한 코드

> 코드가 더 중요해지거나 복잡해질수록 협력자는 더 적어야 한다.
> 좋지 않은 테스트를 작성하는 것보다는 테스트를 전혀 작성하지 않는 편이 낫다.

### 🔖 7.1.2 험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기

![7-4](./img/7-4.png)

- 테스트 대상 코드의 로직을 테스트하려면, 테스트가 가능한 부분을 추출해야 한다. 결과적으로 코드는 테스트 가능한 부분을 둘러싼 얇은 험블 래퍼(humble wrapper)가 된다.
- 육각형 아키텍처와 함수형 아키텍처 모두 험블 객체 패턴 구현
  - 육각형 아키텍처는 business 로직과 프로세스 외부 의존성과의 통신 분리
  - 함수형 아키텍처는 더 나아가 프로세스 외부 의존성뿐만 아니라 모든 협력자와의 커뮤니케이션에서 비지니스 로직을 분리한다. 따라서, 함수형 코어에는 아무런 협력자도 없다. 함수형 코어의 모든 의존성은 불변
- 험블 객체 패턴을 보는 또 다른 방법은 단일 책임 원칙을 지키는 것
  - 이 패턴을 적용하면 비지니스 로직을 거의 모든 것과 분리할 수 있다.

## 📖 7.2 가치 있는 단위 테스트를 위한 리팩터링하기

___

### 🔖 7.2.1 고객 관리 시스템 소개

아래 세 가지 비지니스 규칙이 있다.

- 사용자 이메일이 회사 도메인에 속한 경우 해당 사용자는 직원으로 표시된다. 그렇기 않으면 고객으로 간주한다.
- 시스템은 회사의 직원 수를 추적해야 한다. 사용자 유형이 직원에서 고객으로, 또는 그 반대로 변경되면 이 숫자도 변경해야 한다.
- 이메일이 변경되면 시스템은 메시지 버스로 메시지를 보내 외부 시스템에 알려야 한다.

User 클래스에는 네 개의 의존성이 있으며, 그중 두개는 명시적(userId와 newEmail 인수)이고 나머지 두개(프로세스 외부 협력자: Database와 MessageBus)는 암시적이다.

- 도메인 유의성이 높은 코드에서 프로세스 외부 협력자는 사용하면 안 된다.

![7-7](./img/7-7.png)

#### 활성 레코드 패턴(Active Record)

- 도메인 클래스가 스스로 데이터베이스를 검색하고, 다시 지정하는 방식
- 단순 프로젝트나 단기 프로젝트에서는 잘 작동하지만 코드베이스가 커지면 확장하지 못하는 경우가 많다. business 로직과 프로세스 외부 의존성과의 통신 사이에 분리가 없기 때문

### 🔖 7.2.2 1단계: 암시적 의존성을 명시적으로 만들기

도메인 모델이 프로세스 외부 의존성을 직접 참조하든 인터페이스를 통해 참조하든 상관없다. 의존성은 여전히 프로세스 외부에 있기 때문이다.

- 테스트 유지비⬆️
- 목을 DB 의존성에 사용하면 테스트 취약성 ⬆️

도메인 모델은 직접적으로든 간접적으로든(인터페이스를 통해) 프로세스 외부 협력자에게 의존하지 않는 것이 훨씬 더 깔끔하다. 도메인 모델은 외부 시스템과의 통신을 책임지지 않아야 한다.

### 🔖 7.2.3 2단계: 애플리케이션 서비스 계층 도입

![7-8](./img/7-8.png)

도메인 모델이 외부 시스템과 직접 통신하는 문제를 극복하려면 다른 클래스인 험블 컨트롤러(육각형 아키텍처 분류상 애플리케이션 서비스)로 책임을 옮겨야 한다.

일반적으로 도메인 클래스는 다른 도메인 클래스나 단순 값과 같은 프로세스 내부 의존성에만 의존해야 한다.

### 🔖 7.2.4 3단계: 애플리케이션 서비스 복잡도 낮추기

UserController가 컨트롤러 사분면에 확실히 있으려면 재구성 로직을 추출해야 한다.

- ORM을 사용해 데이터베이스를 도메인 모델에 매핑하면, 재구성 로직을 옮기기에 적절한 위치가 될 수 있다.
- ORM을 사용하지 않거나 사용할 수 없으면, 도메인 모델에 원시 데이터베이스 데이터로 도메인 클래스를 인스턴스화하는 팩토리 클래스를 작성하라.

### 🔖 7.2.5 4단계: 새 Company 클래스 소개

![7-9](./img/7-9.png)

모든 복잡도가 팩토리로 이동했기 때문에 UserController는 확실히 컨트롤러 사분면에 속한다. 이 클래스가 담당하는 것은 모든 협력자를 한데 모으는 것이다.

함수형 아키텍처와 비슷한 점

- 함수형 코어도 마찬가지로 프로세스 외부 의존성과 통신하지 않는다.

함수형 아키텍처와 차이점

- 부작용 처리
  - 함수형 코어는 어떠한 부작용도 일으키지 않는다.
  - CRM 도메인 모델은 부작용을 일으키지만, 이러한 모든 부작용은 변경된 사용자 이메일과 직원 수의 형태로 도메인 모델 내부에 남아있다.
  - 부작용이 메모리에 남아있다는 사실로 인해 테스트 용이성이 크게 향상된다. 테스트가 프로세스 외부 의존성을 검사할 필요가 없고 통신 기반 테스트에 의존할 필요도 없다. 메모리에 있는 객체의 출력 기반 테스트와 상태 기반 테스트로 모든 검증을 수행할 수 있다.
