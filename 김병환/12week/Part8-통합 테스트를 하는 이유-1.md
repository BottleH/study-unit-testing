# 📚 8장 통합 테스트를 하는 이유

단위 테스트에만 전적으로 의존하면 시스템이 전체적으로 잘 작동하는지 확신할 수 없다.

- 단위 테스트는 비즈니스 로직을 확인하는 데 좋다.

## 📖 8.1 통합 테스트는 무엇인가?

___

통합 테스트는 테스트 스위트에서 중요한 역할을 하며, 단위 테스트 개수와 통합 테스트 개수의 균형을 맞추는 것도 중요하다.

### 🔖 8.1.1 통합 테스트의 역할

단위 테스트의 요구사항을 하나라도 충족하지 못하는 테스트는 통합 테스트 범주에 속한다.

- 단일 동작 단위를 검증
- 빠르게 수행
- 다른 테스트와 별도로 처리

실제로 통합 테스트는 대부분 시스템이 외부 의존성과 통합해 어떻게 작동하는지를 검증

- 단위 테스트는 도메인 모델을 다룸
- 통합 테스트는 프로세스 외부 의존성과 도메인 모델을 연결하는 코드를 확인

### 🔖 8.1.2 다시 보는 테스트 피라미드

단위 테스트와 통합 테스트의 비율은 프로젝트의 특성에 따라 다를 수 있지만, 일반적인 경험에 비춰본 규칙은 다음과 같다.

- 단위 테스트로 가능한 한 많이 비즤스 시나리오의 예외 상황을 확인
- 통합 테스트는 주요 흐름과 단위 테스트가 다루지 못하는 기타 예외 상황을 다룸
- 대부분을 단위 테스트로 전환하면 유지비 절감
- 중요한 통합 테스트가 비즈니스 시나리오당 하나 또는 두개가 있으면 시스템 전체의 정확도를 보장

![8-2](./img/8-2.png)

### 🔖 8.1.3 통합 테스트와 빠른 실패

#### 빠른 실패 원칙

예기치 않은 오류가 발생하자마자 현재 연산을 중단하는 것

- 피드백 루프 단축
- 지속성 상태 보호

## 📖 8.2 어떤 프로세스 외부 의존성을 직접 테스트해야 하는가?

___

### 🔖 8.2.1 프로세스 외부 의존성의 두 가지 유형

- 관리 의존성
  - 전체를 제어할 수 있는 프로세스 외부 의존성
  - 데이터베이스
- 비관리 의존성
  - 전체를 제어할 수 없는 프로세스 외부 의존성
  - SMTP서버, 메시지 버스

관리 의존성은 실제 인스턴스를 사용하고, 비관리 의존성은 목으로 대체

### 🔖 8.2.2 관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기

예를 들어, 일부 테이블만 여러 시스템에 접근 권한을 공유한 경우 데이터베이스는 관리 의존성이면서 비관리 의존성이다.

- 일부 테이블만 비관리 의존성으로 취급
- 목으로 테스트 대체
- 나머지 테이블을 관리 의존성으로 처리하고, 상호작용을 검증하지 말고 최종상태를 확인

### 🔖 8.2.3 통합 테스트에서 실제 데이터베이스를 사용할 수 없으면 어떻게 할까?

이런 경우에는 데이터베이스를 목으로 처리해야 된다고 생각하기 쉽지만 그렇지 않다.

- 통합 테스트의 리팩터링 내성이 저하되기 때문
- 회귀방지도 저하

결국 통합 테스트가 검증할 수 있는 것이 거의 없다. 따라서, 통합 테스트를 아예 작성하지 말고 도메인 모델의 단위 테스트에만 집중하라.

## 📖 8.3 통합테스트: 예제

___

7장의 CRM 시스템에 데이터베이스에서 사용자와 회사를 검색하고 의사 결정을 도메인 모델에 위임한 다음, 결과를 데이터베이스에 다시 저장하고 필요한 경우 메시지 버스에 메시지를 싣는다.

### 🔖 8.3.1 어떤 시나리오를 테스트할까?

```java
public void changing_email_from_corporate_to_non_corporate()
```

### 🔖 8.3.2 데이터베이스와 메시지 버스 분류하기

통합테스트는

- 데이터베이스에 사용자와 회사를 삽입
- 해당 데이터베이스에서 이메일 변경 시나리오를 실행
- 데이터베이스 상태를 검증

### 🔖 8.3.3 엔드 투 엔드 테스트는 어떤가?

통합 테스트 보호 수준이 E2E테스트와 비슷해지면 생략이 가능하고, 프로젝트의 상태 점검을 위해 E2E 테스트를 작성할 수 있다.

- E2E는 관리 의존성을 직접 확인해서는 안 되고, 애플리케이션을 통해 간접적으로 확인해야 한다.

## 📖 8.4 의존성 추상화를 위한 인터페이스 사용

___

### 🔖 8.4.1 인터페이스의 느슨한 결합

인터페이스에 구현이 하나만 있는 경우가 많은데 관습적으로 많이 쓴다. 그 이유는

- 프로세스 외부 의존성을 추상화해 느슨한 결합을 달성하고,
- 기존 코드를 변경하지 않고 새로운 기능을 추가해 OCP을 지키기 때문

물론 모두 오해다. 진정으로 추상화되려면 구현이 두 가지는 있어야 하고, YAGNI 원칙도 위반한다.

- 현재 필요하지 않은 기능에 시간을 들이지 말라

### 🔖 8.4.2 프로세스 외부 의존성에 인터페이스를 사용하는 이유는 무엇인가?

목을 사용하기 위함이다.

- 목으로 처리할 필요가 없다면 프로세스 외부 의존성에 대한 인터페이스를 두지 말라.
- 진정한 추상화(구현이 둘 이상)는 목과 상관없이 인터페이스로 나타낼 수 있다.

### 🔖 8.4.3 프로세스 내부 의존성을 위한 인터페이스 사용

프로세스 외부 의존성뿐만 아니라 프로세스 내부 의존성도 인터페이스 기반인 코드를 볼 수 있다.

- 구현이 하나만 있다면 좋지 않다.
- 깨지기 쉬운 테스트와 리팩터링 내성이 떨어지게 된다.
