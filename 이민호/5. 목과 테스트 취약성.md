# 5. 목과 테스트 취약성

```
ㅁ. 목과 스텁 구분
ㅁ. 식별할 수 있는 동작과 구현 세부 사항 정의
ㅁ. 목과 테스트 취약성간의 관계 이해
ㅁ. 리팩터링 내성 저하 없이 목 사용하기
```
---
- 목이 취약한 테스트 (리팩터링 내성이 부족한 테스트)
- 복습) 런던파 : 테스트 대상 코드 조각을 서로 분리하고, 불변 의존성을 제외한 모든 의존성에 테스트 대역을 써서 격리하자
- 복습) 고전파 : 테스트간 공유하는 의존성에 대해서만 테스트 대역을 사용하자

## 5.1 목과 스텁 구분
### 5.1.1 테스트 대역 유형
- 목 (목, 스파이) : 외부로 나가는 상호 작용을 **'모방 및 검사'** (ex SUT -> 이메일발송 -> SMTP 서버)
- 스텁 (스텁, 더미, 페이크) : 내부로 들어오는 상호 작용을 **'모방'** (ex 데이터베이스 -> 데이터 검색 -> SUT)
### 5.1.2 도구로서의 목과 테스트 대역으로서의 목
- 목 라이브러리 (mocking library) : 실제 목을 만드는데 도움이 되지만, 그 자체로는 목(Mock)이 아닌 클래스.(즉, 도구로서의 목으로 사용됨)
### 5.1.3 스텁으로 상호 작용을 검증하지 말라
- 스텁 : SUT 가 출력을 생성하도록 입력만 제공한다 (검증의 대상이 아님). 만약, 스텁과의 상호 작용을 검증한다면 이는 취약한 테스트를 야기한다.
- 복습) 테스트에서 거짓 양성을 피하고, 리팩터링 내성을 향상시키는 방법은 **'구현 세부 사항'** 이 아닌 **'최종 결과'** 를 검증하는 것 뿐이다.
- 과잉 명세 : 최종 결과가 아닌 세부 사항을 검증하는 것. (ex 상호 작용을 검사할 때 흔하게 발생함)
### 5.1.5 목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?
- 명령 조회 분리 원칙 (Command Query Separation) : 모든 메서드는 명령이나 조회여야 하며, 이 둘을 혼용해서는 안 된다. (ex 질문을 할 때 마다 답이 달라져서는 안 된다.)
- 명령 (목) : 사이드 이펙트 O & 값 반환 여부 X
- 조회 (스텁) : 사이드 이펙트 X & 값 반환 여부 O

## 5.2 식별할 수 있는 동작과 구현 세부 사항
- 복습) 테스트 취약성은 좋은 단위 테스트의 두 번째 특성인 **'리팩토링 내성'** 에 해당한다.
- 복습) 테스트에 거짓 양성이 있는 주요 있는 이유는 코드의 **'구현 세부 사항'** 과 결합돼 있기 때문이다.

### 5.2.1 식별할 수 있는 동작은 공개 API와 다르다
- 제품 코드의 분류법은 아래와 같이 2차원이다.
```
1) 공개 API or 비공개 API
2) 식별할 수 있는 동작 or 구현 세부 사항
```
- 식별할 수 있는 동작 (잘 설계된 API)
```
1) 클라이언트가 목표를 달성하는 데 도움이 되는 작업을 노출
2) 클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출
```
- 잘 설계된 API : 공개 API = 식별할 수 있는 동작 / 비공개 API = 구현 세부 사항

### 5.2.3 잘 설계된 API와 캡슐화
- 복습) 캡슐화 : 불변성 위반의 모순을 방지하는 조치 
```
1) 구현 세부 사항을 숨기면, 클라이언트 시야에서 클래스 내부를 가릴 수 있기 때문에 내부를 손상시킬 위험이 적다
2) 데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다.
```
### 5.2.4 구현 세부 사항 유출 : 상태의 예
- 공개 API : 식별할 수 있는 동작 (좋음) / 구현 세부 사항 (나쁨)
- 비공개 API : 식별할 수 있는 동작 (해당 없음) / 구현 세부 사항 (좋음)