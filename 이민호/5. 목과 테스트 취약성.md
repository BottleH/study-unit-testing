# 5. 목과 테스트 취약성

```
ㅁ. 목과 스텁 구분
ㅁ. 식별할 수 있는 동작과 구현 세부 사항 정의
ㅁ. 목과 테스트 취약성간의 관계 이해
ㅁ. 리팩터링 내성 저하 없이 목 사용하기
```
---
- 목이 취약한 테스트 (리팩터링 내성이 부족한 테스트)
- 복습) 런던파 : 테스트 대상 코드 조각을 서로 분리하고, 불변 의존성을 제외한 모든 의존성에 테스트 대역을 써서 격리하자
- 복습) 고전파 : 테스트간 공유하는 의존성에 대해서만 테스트 대역을 사용하자

## 5.1 목과 스텁 구분
### 5.1.1 테스트 대역 유형
- 목 (목, 스파이) : 외부로 나가는 상호 작용을 **'모방 및 검사'** (ex SUT -> 이메일발송 -> SMTP 서버)
- 스텁 (스텁, 더미, 페이크) : 내부로 들어오는 상호 작용을 **'모방'** (ex 데이터베이스 -> 데이터 검색 -> SUT)
### 5.1.2 도구로서의 목과 테스트 대역으로서의 목
- 목 라이브러리 (mocking library) : 실제 목을 만드는데 도움이 되지만, 그 자체로는 목(Mock)이 아닌 클래스.(즉, 도구로서의 목으로 사용됨)
### 5.1.3 스텁으로 상호 작용을 검증하지 말라
- 스텁 : SUT 가 출력을 생성하도록 입력만 제공한다 (검증의 대상이 아님). 만약, 스텁과의 상호 작용을 검증한다면 이는 취약한 테스트를 야기한다.
- 복습) 테스트에서 거짓 양성을 피하고, 리팩터링 내성을 향상시키는 방법은 **'구현 세부 사항'** 이 아닌 **'최종 결과'** 를 검증하는 것 뿐이다.
- 과잉 명세 : 최종 결과가 아닌 세부 사항을 검증하는 것. (ex 상호 작용을 검사할 때 흔하게 발생함)
### 5.1.5 목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?
- 명령 조회 분리 원칙 (Command Query Separation) : 모든 메서드는 명령이나 조회여야 하며, 이 둘을 혼용해서는 안 된다. (ex 질문을 할 때 마다 답이 달라져서는 안 된다.)
- 명령 (목) : 사이드 이펙트 O & 값 반환 여부 X
- 조회 (스텁) : 사이드 이펙트 X & 값 반환 여부 O

## 5.2 식별할 수 있는 동작과 구현 세부 사항
- 복습) 테스트 취약성은 좋은 단위 테스트의 두 번째 특성인 **'리팩토링 내성'** 에 해당한다.
- 복습) 테스트에 거짓 양성이 있는 주요 있는 이유는 코드의 **'구현 세부 사항'** 과 결합돼 있기 때문이다.

### 5.2.1 식별할 수 있는 동작은 공개 API와 다르다
- 제품 코드의 분류법은 아래와 같이 2차원이다.
```
1) 공개 API or 비공개 API
2) 식별할 수 있는 동작 or 구현 세부 사항
```
- 식별할 수 있는 동작 (잘 설계된 API)
```
1) 클라이언트가 목표를 달성하는 데 도움이 되는 작업을 노출
2) 클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출
```
- 잘 설계된 API : 공개 API = 식별할 수 있는 동작 / 비공개 API = 구현 세부 사항

### 5.2.3 잘 설계된 API와 캡슐화
- 복습) 캡슐화 : 불변성 위반의 모순을 방지하는 조치 
```
1) 구현 세부 사항을 숨기면, 클라이언트 시야에서 클래스 내부를 가릴 수 있기 때문에 내부를 손상시킬 위험이 적다
2) 데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다.
```
### 5.2.4 구현 세부 사항 유출 : 상태의 예
- 공개 API : 식별할 수 있는 동작 (좋음) / 구현 세부 사항 (나쁨)
- 비공개 API : 식별할 수 있는 동작 (해당 없음) / 구현 세부 사항 (좋음)

## 5.3 목과 테스트 취약성 간의 관계

### 5.3.1 육각형 아키텍처 정의
- 애플리케이션은 도메인(비즈니스 로직 구현 - 연산, 상태) 계층과 애플리케이션 서비스 계층(외부 환경과의 통신을 조정)으로 구성되며, 이때 서비스 계층과 도메인 계층의 조합은 **'육강형'** 을 형성한다.
- 육각형 아키텍처
```
1) 도메인 계층과 애플리케이션 서비스 계층 간의 관심사 분리 : 애플리케이션 서비스에너느 어떤 비즈니스 로직도 있으면 안 된다.
2) 애플리케이션 내부 통신 : 애플리케이션 서비스 계층에서 도메인 계층으로 흐르는 단방향 의존성 흐름을 규정함.
3) 애플리케이션 간의 통신 : 외부 애플리케이션은 애플리케이션 서비스 계층에 있는 공통 인터페이스를 통해 해당 애플리케이션에 연결된다.
```
- 프랙탈 특성 : 서로 다른 계층의 테스트가 동일한 동작을 서로 다른 수준으로 검증하는 특성 (작은 구조가 전체 구조와 닮은 형태로 끝없이 되풀이되는 구조)
- (복습) **'잘 설계된'** API 로 코드베이스를 검증하는 테스트는 식별할 수 있는 동작만 결합돼 있기 때문에 비즈니스 요구 사항과 관계가 있다.
### 5.3.2 시스템 내부 통신과 시스템 간 통신
- 시스템 간 내부 통신 : 연산을 수행하기 위한 도메인 간의 협력을 나타내므로, 구현 세부 사항(식별 불가)에 해당한다.
- 시스템 간 통신 : 시스템 외부 환경과 통신하므로 식별할 수 있는 동작을 의미한다.
## 5.4 단위 테스트의 고전파와 런던파 재고
- (복습) 고전파와 런던파간의 차이점
```
- 런던파 : 단위 (격리 주체) / 단위 클래스 (단위의 크기) / 불변 의존성 외 모든 의존성 (테스트 대역 사용 대상) 
- 고전파 : 단위 테스트 (격리주체) / 단일 클래스 또는 클래스 세트 (단위의 크기) / 공유 의존성
```
- (저자 의견) 고전파 선호 이유 : 런던파는 불변 의존성을 제외한 모든 의존성에 목 사용을 권장하며, 시스템 내 통신과 시스템 간 통신을 구분하지 않는다. 그 결과 클래스간 통신도 테스트함으로써 테스트가 구현 세부 사항에 강하게 결합되게 된다.

### 5.4.1 모든 프로세스 외부 의존성을 목으로 해야 하는 것은 아니다
- (복습) 의존성 유형
```
1) 공유 의존성 : 테스트 간 공유하는 의존성
2) 프로세스 외부 의존성 : 다른 프로세스를 점유하는 의존성 (데이터베이스, 메시지 버스, SMTP 등)
3) 비공개 의존성 : 공유하지 않는 모든 의존성
``` 
- 모든 프로세스 외부 의존성을 목으로 대체해야 하는 것은 아니다 (ex 애플리케이션 데이터베이스)
```
1) 프로세스 외부 의존성이 애플리케이션을 통해서만 접근할 수 있으면, 이는 클라이언트가 식별할 수 있는 동작이 아니다.
2) 애플리케이션이 외부 시스템에 대한 프록시 역할을 수행해 클라이언트가 직접 접근할 수 없으면 하위 호환성 요구가 사라진다. (같이 배포하면 되므로)
3) 즉, 완전히 통제권을 가진 프로세스 외부 의존성을 목으로 대체하면 깨지기 쉬운 테스트로 이어진다.
```