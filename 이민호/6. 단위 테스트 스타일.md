# 6. 단위 테스트 스타일

```
a. 단위 테스트 스타일 비교
b. 함수형 아키텍처와 육각형 아키텍처의 관계
c. 출력 기반 테스트로 전환
```
---

## 6.1 단위 테스트의 세가지 스타일
```
a. 출력 기반 테스트
b. 상태 기반 테스트
c. 통신 기반 테스트
```
- (NOTE) 하나의 테스트에서 세 가지 스타일 모두 사용 할 수 있음 
### 6.1.1 출력 기반 테스트 정의
- 정의 : 테스트 대상 시스템(SUT)에 입력을 넣고 생성되는 출력을 점검하는 방식 (즉, 반환값만 검증함)
- 출력 기반 테스트 스타일은 **'함수형(functional)'** 이라고도 한다. 
### 6.1.2 상태 기반 테스트 정의
- 정의 : 작업이 완료된 후 시스템의 상태를 확인하는 방식. 이때 **'상태'** 는 SUT or 협력자 혹은 데이터베이스나 파일 시스템 등과 같은 **'외부 의존성'** 의 상태를 의미할 수 있음.
### 6.1.3 통신 기반 테스트 정의
- 정의 : 목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증하는 방식
---
## 6.2 단위 테스트 스타일 비교
```
a. 회귀 방지 : 이전에 제대로 작동하던 소프트웨어 기능에 문제가 생기는 것을 방지하는 것을 의미
b. 리팩터링 내성 : 테스트를 실패하지 않고 기존 애플리케이션 코드를 리팩토링 할 수 있는지에 대한 척도
c. 빠른 피드백 : 테스트 속도가 빠를 수록 테스트 스위트에서 더 많이 & 더 자주 테스트를 수행할 수 있는 것을 의미
d. 유지 보수성 : 테스트가 얼마나 이해하기 어려운가 & 테스트가 얼마나 실행하기 어려운가에 대해 평가 척도
```
### 6.2.1 회귀 방지와 피드백 속도 지표로 스타일 비교하기
- 회귀 방지 : 회귀 방지 지표는 (테스트 중 실행되는 코드 양 / 코드 복잡도 / 도메인 유의성) 특정 테스트 스타일에 따라 **'달라지지 않는다'**.
- 피드백 속도 : 테스트 스타일과 테스트 피드백 속도 사이에는 상관관계가 **'거의 없다.'**
### 6.2.2 리팩터링 내성 지표로 스타일 비교하기
- 출력 기반 : 출력 기반 테스트는 테스트 대상 메서드에만 결합되므로 거짓 양성 방지가 가장 좋다. 
- 상태 기반 : 테스트 대상 메서드외에 클래스 상태와 함께 동작하므로 거짓 양성이 되기 쉽다.
- 통신 기반 : 스텁과 상호 작용을 확인하는 테스트는 대부분 깨지기 쉽다. 즉, 허위 정보에 가장 취약하다.
### 6.2.3 유지 보수성 지표로 스타일 비교하기
- 출력 기반 : 출력 기반 테스트는 항상 짧고 간결하므로, 유지 보수가 쉽다.
- 상태 기반 : 출력 기반 테스트보다 **'더 많은 공간'** (코드 라인 or 검증 문) 을 차지하므로 유지 보수가 쉽지 않다.
- 통신 기반 : 출력 기반, 상태 기반 테스트보다 **'더 점수가 낮다'**. (테스트 대역과 상호 작용을 검증을 설정해야 하며, 이는 공간을 많이 차지 하기 때문)
### 6.2.4 스타일 비교하기: 결론 (출력 기반 테스트 스타일이 가장 좋다)
- 리팩터링 내성을 지키기 위해 필요한 노력 : 출력 기반 ↓ / 상태 기반 → / 통신 기반 →
- 유지비 : 출력 기반 ↓ / 상태 기반 → / 통신 기반 ↑
---
## 6.3 함수형 아키텍처 이해
### 6.3.1 함수형 프로그래밍이란?
- 함수형 프로그래밍 : **'수학적 함수'** 를 사용한 프로그래밍을 의미한다.
- 수학적 함수 : **'숨은 입출력이 없는 함수'** 를 의미하며, 모든 입출력이 메서드 이름, 인수, 반환 타입으로 구성된 메서드 시그니처(method signature)에 명시된 함수를 의미한다.
- 숨은 입출력 종류
```
a. 사이드 이펙트 : 시그니처에 표시되지 않은 출력.
b. 예외 : 메서드가 예외를 던지면, 프로그램 흐름에 메서드 시그니처에 설정된 계약을 우회하는 경로를 만든다.
c. 내외부 상태에 대한 참조 : 데이터베이스에서 데이터를 질의하거나, 비공개 변경 가능 필드를 참조하는 등의 행위는 메서드 시그니처에 없는 실행 흐름에 대한 입력이다.
```
- 입출력을 명시한 수학적 함수는 이에 따르는 테스트가 짧고 간결하며 이해하고 유지 보수하기 쉬우므로 **'테스트하기 매우 쉽다'**.
### 6.3.2 함수형 아키텍처란?
- 함수형 프로그래밍의 목표 : 사이드 이펙트를 완전히 제거하는 것이 아닌, 비즈니스 로직을 처리하는 코드와 사이드 이펙트를 일으키는 코드를 **'분리'** 하는 것을 목표로함. (어떤 사이드 이펙트도 일으키지 않는 어플리케이션은 비현실적임)
- 함수형 아키텍처 : 사이드 이펙트를 다루는 코드를 최소화하면서, 순수 함수 (불변) 방식으로 작성한 코드의 양을 극대화 한다.
```
a. 결정을 내리는 코드 (코어) : 사이드 이펙트가 필요 없기 때문에 수학적 함수를 사용해 작성할 수 있다.
b. 해당 결정에 따라 적용하는 코드 (가변 셀) : 수학적 함수에 의해 이뤄진 모든 결정을 데이터베이스의 변경이나, 메시지 버스로 전송된 메시지와 같이 가시적인 부분으로 변환한다. 
```
- 함수형 코어와 가변 셀의 협력
```
a. 가변 셀은 모든 입력을 수집한다.
b. 함수형 코어는 결정을 생성한다.
c. 셀은 결정을 사이드 이펙트로 변환한다.
```
### 6.3.3 함수형 아키텍처와 육각형 아키텍처 비교
- **유사점 (관심사 분리라는 아이디어를 기반으로함)** : 육각형 아키텍처 (도메인 계층과 서비스 계층의 분리) / 함수형 아키텍처 (결정과 실행을 분리)
- **차이점 (사이드 이펙트에 대한 처리)** : 육각형 아키텍처 (모든 수정 사항은 도메인 계층 내에 있어야 하며, 계층의 경계를 넘을 수 없다) / 함수형 아키텍처 (모든 사이드 이펙트를 불변 코어에서 비즈니스 연산 가장자리로 밀어낸다)


