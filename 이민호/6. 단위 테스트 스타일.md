# 6. 단위 테스트 스타일

```
a. 단위 테스트 스타일 비교
b. 함수형 아키텍처와 육각형 아키텍처의 관계
c. 출력 기반 테스트로 전환
```
---

## 6.1 단위 테스트의 세가지 스타일
```
a. 출력 기반 테스트
b. 상태 기반 테스트
c. 통신 기반 테스트
```
- (NOTE) 하나의 테스트에서 세 가지 스타일 모두 사용 할 수 있음 
### 6.1.1 출력 기반 테스트 정의
- 정의 : 테스트 대상 시스템(SUT)에 입력을 넣고 생성되는 출력을 점검하는 방식 (즉, 반환값만 검증함)
- 출력 기반 테스트 스타일은 **'함수형(functional)'** 이라고도 한다. 
### 6.1.2 상태 기반 테스트 정의
- 정의 : 작업이 완료된 후 시스템의 상태를 확인하는 방식. 이때 **'상태'** 는 SUT or 협력자 혹은 데이터베이스나 파일 시스템 등과 같은 **'외부 의존성'** 의 상태를 의미할 수 있음.
### 6.1.3 통신 기반 테스트 정의
- 정의 : 목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증하는 방식
---
## 6.2 단위 테스트 스타일 비교
```
a. 회귀 방지 : 이전에 제대로 작동하던 소프트웨어 기능에 문제가 생기는 것을 방지하는 것을 의미
b. 리팩터링 내성 : 테스트를 실패하지 않고 기존 애플리케이션 코드를 리팩토링 할 수 있는지에 대한 척도
c. 빠른 피드백 : 테스트 속도가 빠를 수록 테스트 스위트에서 더 많이 & 더 자주 테스트를 수행할 수 있는 것을 의미
d. 유지 보수성 : 테스트가 얼마나 이해하기 어려운가 & 테스트가 얼마나 실행하기 어려운가에 대해 평가 척도
```
### 6.2.1 회귀 방지와 피드백 속도 지표로 스타일 비교하기
- 회귀 방지 : 회귀 방지 지표는 (테스트 중 실행되는 코드 양 / 코드 복잡도 / 도메인 유의성) 특정 테스트 스타일에 따라 **'달라지지 않는다'**.
- 피드백 속도 : 테스트 스타일과 테스트 피드백 속도 사이에는 상관관계가 **'거의 없다.'**
### 6.2.2 리팩터링 내성 지표로 스타일 비교하기
- 출력 기반 : 출력 기반 테스트는 테스트 대상 메서드에만 결합되므로 거짓 양성 방지가 가장 좋다. 
- 상태 기반 : 테스트 대상 메서드외에 클래스 상태와 함께 동작하므로 거짓 양성이 되기 쉽다.
- 통신 기반 : 스텁과 상호 작용을 확인하는 테스트는 대부분 깨지기 쉽다. 즉, 허위 정보에 가장 취약하다.
### 6.2.3 유지 보수성 지표로 스타일 비교하기
- 출력 기반 : 출력 기반 테스트는 항상 짧고 간결하므로, 유지 보수가 쉽다.
- 상태 기반 : 출력 기반 테스트보다 **'더 많은 공간'** (코드 라인 or 검증 문) 을 차지하므로 유지 보수가 쉽지 않다.
- 통신 기반 : 출력 기반, 상태 기반 테스트보다 **'더 점수가 낮다'**. (테스트 대역과 상호 작용을 검증을 설정해야 하며, 이는 공간을 많이 차지 하기 때문)
### 6.2.4 스타일 비교하기: 결론 (출력 기반 테스트 스타일이 가장 좋다)
- 리팩터링 내성을 지키기 위해 필요한 노력 : 출력 기반 ↓ / 상태 기반 → / 통신 기반 →
- 유지비 : 출력 기반 ↓ / 상태 기반 → / 통신 기반 ↑
---
## 6.3 함수형 아키텍처 이해
### 6.3.1 함수형 프로그래밍이란?
- 함수형 프로그래밍 : **'수학적 함수'** 를 사용한 프로그래밍을 의미한다.
- 수학적 함수 : **'숨은 입출력이 없는 함수'** 를 의미하며, 모든 입출력이 메서드 이름, 인수, 반환 타입으로 구성된 메서드 시그니처(method signature)에 명시된 함수를 의미한다.
- 숨은 입출력 종류
```
a. 사이드 이펙트 : 시그니처에 표시되지 않은 출력.
b. 예외 : 메서드가 예외를 던지면, 프로그램 흐름에 메서드 시그니처에 설정된 계약을 우회하는 경로를 만든다.
c. 내외부 상태에 대한 참조 : 데이터베이스에서 데이터를 질의하거나, 비공개 변경 가능 필드를 참조하는 등의 행위는 메서드 시그니처에 없는 실행 흐름에 대한 입력이다.
```
- 입출력을 명시한 수학적 함수는 이에 따르는 테스트가 짧고 간결하며 이해하고 유지 보수하기 쉬우므로 **'테스트하기 매우 쉽다'**.
### 6.3.2 함수형 아키텍처란?
- 함수형 프로그래밍의 목표 : 사이드 이펙트를 완전히 제거하는 것이 아닌, 비즈니스 로직을 처리하는 코드와 사이드 이펙트를 일으키는 코드를 **'분리'** 하는 것을 목표로함. (어떤 사이드 이펙트도 일으키지 않는 어플리케이션은 비현실적임)
- 함수형 아키텍처 : 사이드 이펙트를 다루는 코드를 최소화하면서, 순수 함수 (불변) 방식으로 작성한 코드의 양을 극대화 한다.
```
a. 결정을 내리는 코드 (코어) : 사이드 이펙트가 필요 없기 때문에 수학적 함수를 사용해 작성할 수 있다.
b. 해당 결정에 따라 적용하는 코드 (가변 셀) : 수학적 함수에 의해 이뤄진 모든 결정을 데이터베이스의 변경이나, 메시지 버스로 전송된 메시지와 같이 가시적인 부분으로 변환한다. 
```
- 함수형 코어와 가변 셀의 협력
```
a. 가변 셀은 모든 입력을 수집한다.
b. 함수형 코어는 결정을 생성한다.
c. 셀은 결정을 사이드 이펙트로 변환한다.
```
### 6.3.3 함수형 아키텍처와 육각형 아키텍처 비교
- **유사점 (관심사 분리라는 아이디어를 기반으로함)** : 육각형 아키텍처 (도메인 계층과 서비스 계층의 분리) / 함수형 아키텍처 (결정과 실행을 분리)
- **차이점 (사이드 이펙트에 대한 처리)** : 육각형 아키텍처 (모든 수정 사항은 도메인 계층 내에 있어야 하며, 계층의 경계를 넘을 수 없다) / 함수형 아키텍처 (모든 사이드 이펙트를 불변 코어에서 비즈니스 연산 가장자리로 밀어낸다)

## 6.4 함수형 아키텍처와 출력 기반 테스트로의 전환
```
ㅁ. 프로세스 외부 의존성에서 목으로 변경
ㅁ. 목에서 함수형 아키텍처로 변경
```
### 6.4.1 감사 시스템 소개
[ 감사 시스템 작업 목록 ]
```
ㅁ. 작업 디렉터리에서 전체 파일 목록을 검색
ㅁ. 인덱스 별로 정렬
ㅁ. 아직 감사 파일이 없을 경우 단일 레코드로 첫 번째 파일 생성
ㅁ. 기존 감사 파일이 있으면 최신 파일을 가져와서 파일의 항목 수가 한계에 도달했는지에 따라 새 레코드를 추가하거나 새 파일을 생성 
```
- 위 감사 시스템은 **'파일 시스템과 밀접하게 연결돼 있어서'**
   - 테스트 전 파일을 올바른 위치에 배치해야 하고
   - 테스트가 끝나면 해당 파일을 읽고 내용 확인 후 삭제가 필요하다
   - 그 결과 **'빠른 피드백'** 과 **'유지 보수성'** 이 좋지 않다.

### 6.4.2 테스트를 파일 시스템에서 분리하기 위한 목 사용
- 테스트가 위와 같이 밀접하게 결합된 문제는 일반적으로 **'파일 시스템을 목으로 처리해'** 해결한다.
- 파일 시스템이 **'목으로 대체된 감사 시스템은'** 
  - 더 이상 파일 시스템에 접근하지 않으므로 **'더 빨리 실행된다'**
  - 테스트를 만족시키려고 파일 시스템을 다룰 필요가 없으므로 **'유지비도 절감된다'**
  
### 6.4.3 함수형 아키텍처로 리팩터링하기

- 목으로 대체된 감사 시스템을 **'함수형 아키텍처로'** 리팩터링 하면 **'사이드 이펙트(파일 변경)'** 를 **'클래스 외부(가변셀)'** 로 완전히 이동시킬 수 있다.
- AuditManager 는 이제 **'함수형 코어'** 로써 동작하며, 수행하려는 **'사이드 이펙트(파일 변경)'** 에 대한 명령을 반환한다.
- 이때 **'함수형 코어'** 와 **'가변 셀'** 을 연결시키기 위해 **'애플리케이션 서비스'** 가 외부 클라이언트를 위한 시스템의 진입점을 제공한다.

## 6.5 함수형 아키텍처의 단점 이해하기

### 6.5.1 함수형 아키텍처 적용 가능성
- 기존 감사 시스템은 결정을 내리기 전에 입력을 모두 수집할 수 있으므로, 함수형 아키텍처가 잘 동작했다.
- 그런데 만약, 의사 결정 절차의 중간 결과에 따라 프로세스 외부 의존성에서 추가 데이터를 질의한다면?
  - 시스템 내부에 숨은 입력이 생기므로, **'수학적 함수(함수형 프로그래밍)'** 가 될 수 없으며, 결과적으로 **'출력 기반 테스트'** 를 적용할 수 없다.

### 6.5.2 성능 단점
- 출력 기반 테스트로 리팩토링된 테스트는 목을 사용한 테스트만큼 **'빠르게 작동한다'**. (그래도 어느정도 성능 저하는 발생한다.)
- 따라서, 함수형 아키텍처(출력 기반 테스트)와 전통적인 아키텍처 사이의 선택은, **'성능'** 과 **'코드 유지 보수성'** 간의 절충이므로
  - 만약, 성능 영향이 그다지 눈에 띄지 않는 시스템이라면 함수형 아키텍처를 사용해 유지 보수성을 향상시키고
  - 그렇지 않다면 전통적인 아키텍처를 선택해 목으로 테스트를 리팩토링 하면 된다.

### 6.5.3 코드베이스 크기 증가
- 함수형 아키텍처는 **'함수형 코어(불변 코어)'** 와 **'가변 셀'** 사이를 명확하게 분리해야한다.
- 즉, 궁극적으로 **'코드 복잡도'** 가 낮아지고 **'유지 보수성'** 이 향상되지만, **'초기에 코딩이 더 필요하다'**.
  - 그러나 모든 프로젝트가 위와 같은 초기 투자가 **'타당할 만큼 복잡가 높은 것'** 은 아니다. (비즈니스 관점에서 중요하지 않을 수도 있다)
  - 따라서, **'시스템의 복잡도'** 와 **'중요성'** 을 고려해 함수형 아키텍처를 전략적으로 적용할 필요가 있다.