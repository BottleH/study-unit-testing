# [Unit Testing] 6장 단위 테스트 스타일

###6.1 단위 테스트의 3가지 스타일
- 출력 기반 테스트
  - ![출력기반](https://user-images.githubusercontent.com/58027908/229515670-5cf6e79e-8703-4a0c-9d19-0901344b9705.jpg)
  - 테스트 대상 시스템에 입력을 넣고 생성되는 출력을 점검하는 방식
  - 출력기반 테스트 스타일은 함수형이라고도 한다. (사이드 이펙트가 없는 코드를 선호 강조)
- 상태 기반 테스트
  - ![상태기반](https://user-images.githubusercontent.com/58027908/229516712-d236d5f3-0594-4bd5-a788-9b6b7658571e.jpg)
  - 작업이 완료된 후 시스템 상태를 확인하는것 (상태라는 용어는 SUT 나 협력자중 하나 혹은 외부 의존성) 
- 통신 기반 테스트
  - ![통신기반](https://user-images.githubusercontent.com/58027908/229517086-e8b28fd2-b21b-4cfd-b5b5-26436a928cc1.jpg)
  - 목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증한다.

###6.2 단위테스트 스타일 비교
- 회귀방지 지표 로 스타일 비교 
  - 테스트중 실행되는 코드양
  - 코드 복잡도
  - 도메인 유의성
  - 위의 3가지 특성은 테스트 스타일에 도움이 되지않는다. 
    - 통신기반 테스트 스타일에 한가지 예외는 남용하게 되면 코드 조각을 검증하고 다른 것은 모두 목을 사용하는 피상적인 테스트가 될수있다.
- 피드백 속도로 스타일 비교
  - 테스트 스타일과 테스트 피드백 속도 사이에는 상관관계가 거의 없다.
  - 테스트가 프로세스 외부 의존성과 떨어져 단위 테스트 영역에 있는한 모든 스타일은 테스트 실행 속도가 거의 동일
- 리팩터링 내성 으로 스타일 비교
  - 리팩터링 내성은 리팩터링중 발생하는 거짓양성수에 대한 척도
  - 출력기반 테스트는 테스트가 테스트 대상 메서드에만 결합되므로 거짓 양성 방지가 가장우수
  - 상태기반 테스트 일반적으로 거짓양성이 되기쉽다.
    - 큰 API 노출 영역에 의존하므로 구현세부사항과 결합할 가능성이 높기 때문에
  - 통신 기반 테스트
    - 허위 경보에 가장 취약하다.
    - 테스트 대역(스텁사용)으로 상호 작용을 확인하는 테스트는 깨지기 쉽기 떄문에
  - 캘슐화를 잘지키면 테스트를 식별할 수있는 동작에만 결합시 거짓양성을 줄일수 있다.
- 유지보수성 지표로 스타일 비교
  - 유지 보수성은 단위 테스트의 유지비를 측정 하며 두가지 특성이있다.
    - 테스트를 이해하기 얼마나 어려운가?
    - 테스트를 실행하기 얼마나 어려운가?
  - 출력기반 테스트 
    - 가장 유지보수 하기 용이
    - 거의 항상 짧고 간결하므로 유지보수가 쉽다
    - 전역 상태나 내부 상태를 변경할 리 없으므로 프로세스 외부 의존성을 다루지 않음
  - 상태기반 테스트
    - 출력기반 보다 유지보수가 쉽지않다.
    - 출력기반 테스트 보다 공간을 더많이 차지하므로
  - 통신기반 테스트
    - 다른 테스트들 보다 제일 어렵다.
    - 테스트 대역과 상호 작용을 검증을 설정해야 하여 공간을 많이 차지
    - 목이 사슬 형태로 있을 때 테스트는 더 커지고 유지보수가 어렵다.
- 결론
  - 출력기반 테스트가 가장 결과가 좋다.
  - 구현 세부사항과 결합되지 않으므로 리팩터링 내성이 좋고 외부 의존성이 없기때문에 유지보수가 쉽다.

###6.3함수형 아키텍처 이해
- 함수형 프로그래밍이란 수학적 함수를 사용한 프로그래밍
  - 주어진 입력에 동일한 출력을 생성
  - 입출력을 명시한 수학적 함수는 테스트가 짧고 간결하여 이해하고 유지 보수하기 쉬우므로 테스트하기가 매우쉽다.
  - 유지보수성이 뛰어나고 거짓 양성 빈도가 낮다.
- 숨은 입출력은 코드를 테스트 하기 힘들게 한다.
  - 사이드 이펙트
    - 메서드 시그니처에 표시 되지 않은 입출력
    - 클래스 인스턴스의 상태를 변경하고 디스크의 파일을 업데이트하는 등 사이드 이펙트 발생
  - 예외
    - 메서드가 예외를 던지면 메서드 시그니처에 설정된 계약을 우회하는 경로를 만든다.
    - 호출된 예외는 호출 스택의 어느곳에서도 발생할수 있으므로 메서드 시그니처가 전달하지 않는 출력을 추가
  - 내외부 상태에 대한 참조
    - datetime.now 와 같이 정적 속성을 사용해 현재 날짜와 시간을 가져오는 메서드 처럼 메서드 시그니처에 없는 실행 흐름에 대한 입력
- 참조 투명성 
  - 프록그램의 동작을 변경하지 않고 해당 메서드에 대한 호출을 반환값으로 대체할수 있는지 확인
- 함수형 아키텍처란?
  - 비즈니스 로직을 처리하는 코드와 사이드 이펙트를 일으키는 코드를 분리하는것
  - 결정을 내리는 코드 (함수형 코어 functional core,불변코어 immutable core)
    - 사이드 이펙트가 필요 없기 때문에 수학적 함수를 사용해 작성 가능
  - 해당 결정에 따라 적용하는 코드 (가변셸 mutable shell)
    - 수학적 함수에 의해 이뤄진 모든 결정을 데이터베이스의 변경이나 메시지 버스로 전송된 메시지와 같이 가시적인 부분으로 변경
  - 함수형 코어와 가변 셸 협력
    - 가변 셸은 모든 입력을 수집
    - 함수형 코어는 결정을 생성
    - 셸은 결정을 사이드 이펙트로 변환
- 함수형 아키텍처와 육각형 아키텍처 비교
  - 육각형 아키텍처는 도메인 계층과 애플리케이션 서비스 계층을 구별한다.
    - 이는 결정과 실행을 분리하는 함수형 아키텍처와 유사
  - 의존성간 단방향 흐름
    - 육각형 아키텍처는 도메인 계층 내 클래스는 서로에게만 의존 애플리케이션 계층의 클래스는 의존해선 안된다.
    - 함수형 아키텍처의 불변 코어는 가변 셸에 의존하지 않는다.
  - 차이점은 사이드 이펙트에 대한 처리
    - 함수형 아키텍처는 모든 사이드 이펙트를 불변 코어에서 비즈니스 연산 가장자리로 밀어낸다.
      - 가장자리는 가변셸이 처리
    - 육각형 아키텍처는 도메인 계층에 제한 하는한 도메인 계층으로 사이드 이펙트도 문제없다.
      - 모든 수정사항은 도메인 계층 내에 있어야 하며 계층의 경계를 넘어서는 안된다.
  

