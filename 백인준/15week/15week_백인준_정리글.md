# [Unit Testing] 10장 데이터베이스 테스트

- 데이터 베이스를 테스트 하면 회귀방지가 아주 뛰어나지만 설정하기가 쉽지않다.

## 10.1 데이터베이스 테스트를 위한 전제 조건 
- 통합 테스트에서는 관리 의존성이 그대로 있어야 한다.
- 형상 관리 시스템에 데이터베이스 유지
- 모든 개발자를 위한 별도의 데이터베이스 인스턴스 사용
- 데이터베이스 배포에 마이그레이션 기반 방식 적용

### 10.1.1 데이터베이스를 형상 관리 시스템에 유지
- 데이터베이스 스키마를 일반 코드로 취급 
- 데이터베이스 스키마는 Git과 같은 형상 관리 시스템에 저장하는것이 최선
  - 원천 정보를 하나로 할수있고 일반 코드 변경과 함께 데이터베이스 변경을 추적할수있다.
  - 형상관리 외부에서는 데이터베이스 구조를 수정하면 안된다.

### 10.1.2 참조 데이터도 데이터베이스 스키마다.
- 참조 데이터는 애플리케이션의 필수 사항이므로, 테이블,뷰, 그리고 다른 데이터베이스와 함께 SQL INSERT 문
형태로 형상관리 시스템에 저장해야한다.
- 참조데이터는 일반 데이터와 별도로 저장되지만 수정 할수 없는 플래그를 두고 애플리케이션이 참조 변경하지 못하게 해야한다.

### 10.1.3 모든 개발자를 위한 별도의 데이터베이스 인스턴스
- 테스트 실행 속도를 극대화 하려면 개발자마다 별도록 데이터베이스 인스턴스를 사용하라
  - 서로다른 개발자가 실행한 테스트는 서로 간섭되기 때문에
  - 하위 호환성이 없는 변경으로 다른 개발자의 작업을 막을 수 있기 때문이다.

### 10.1.4 상태 기반 데이터베이스 배포와 마이그레이션 기반 데이터베이스 배포
- 마이그레이션 기반방식이 초기에는 구현하고 유지보수하기가 어렵지만 장기적으로는 상태기반보다 효과적

- 상태기반 방식
  - 배포중 비교 도구가 스크립트를 생성해 운영 데이터베이스를 모델 데이터베이스와 비교해 최신 상태로 유지
  - 물리적인 모델 데이터베이스는 원천 데이터가 아니다.
  - 비교도구는 불필요 테이블 삭제 및 모델 데이터베이스와 동기화하는 데 필요한 모든 작업을 수행
- 마이그레이션 기반 방식
  - 데이터베이스를 어떤버전에서 다른 버전으로 전환하는 명시적인 마이그레이션을 의미
  - 운영 데이터베이스와 개발 데이터베이스를 자동으로 동기화하기 위한 도구를 사용할수 없고 업그레이드 스크립트를 직접작성
- 상태 기반 방식보다 마이그레이션 기반 방식을 선호하라
  - 데이터베이스 상태가 명확하면 병합 충돌을 처리하기가 수월한 반면 명시적 마이그레이션은 데이터 모션 문제를 해결하는데 도움

## 10.2 데이터베이스 트랜잭션 관리
- 테스트에서는 운영 환경에 근접한 설정으로 데이터베이스 통합을 검증하는데 도움

### 10.2.1 제품 코드에서 데이터베이스 트랜잭션 관리하기
- 읽기 전용 연산 중에는 여러 트랜잭션을 열어도 괜찮다.
- 데이터 변경이 포함된다면 모순을 피하고자 연산에 포함된 모든 업데이트는 원자적이어야한다.
#### 데이터베이스 트랜잭션에서 데이터베이스 연결 분리하기
- 잠재적인 모순을 피하려면 결정 유형을 두 가지로 나눠야 한다.
  - 업데이트할 데이터
  - 업데이트 유지 또는 롤백 여부
- 데이터베이스 클래스를 리포지토리 , 트랜잭션으로 나눠서 책임을 구분한다.
  - 리포지토리
    - 데이터베이스의 데이터에 대한 접근과 수정을 가능하게 하는 클래스
    - 수명이 짧음 , 데이터베이스 호출 완료시 즉시 폐기
  - 트랜잭션
    - 업데이트를 완전히 커밋하거나 롤백하는 클래스다.
    - 전체 비즈니스 연산 동안 있으면 연산이 끝나면 폐기
#### 작업 단위로 트랜잭션 업그레이드하기
- 작업 단위가 갖는 가장 큰장점은 업데이트 지연
- 비즈니스 연산 종료 시점에 모든 업데이트를 실행하므로 데이터베이스 트랜잭션의 기간을 단축하고 데이터 혼잡을 줄인다.

### 10.2.2 통합 테스트에서 데이터베이스 트랜잭션 관리하기
- 테스트 구절 간에 데이터베이스 트랜잭션이나 작업 단위를 재사용하지 말라
- 동작 모순에 빠지지 않으려면 통합 테스트를 가능한 한 운영 환경에서 비슷하게 해야한다.

## 10.3 테스트 데이터 생명 주기
- 공유 데이터베이스를 사용하려면 통합 테스트를 서로 분리할 수 없는 문제가 생긴다.
  - 문제 해결 방법
    - 통합 테스트를 순차적으로 실행
    - 테스트 실행 간에 남은 데이터를 제거하라

### 10.3.1 병렬 테스트 실행과 순차적 테스트 실행
- 통합 테스트를 병렬로 실행하려면 상당한 노력필요
- 데이터 베이스가 고유한지 확인해야 데이터베이스 제약 조건을 위반하지 않고 테스트가 다른 테스트 후에 입력 데이터를 잘못 수집하는 일이 없다.
- 도커 이미지를 통해 병렬처리를 할수있지만 유지보수 부담이 커지게 된다.

### 10.3.2 테스트 실행 간 데이터 정리
- 각 테스트 전에 데이터베이스 백업 복원하기
  - 데이터 정리 문제를 해결할 수 있지만 느리다.
- 테스트 종료 시점에 데이터 정리하기
  - 빠르지만 정리 단계를 건너뛰기 쉽다.
  - 테스트 도중 빌드 서버가 종료 되거나 디버거에서 테스트를 종료하면 입력 데이터가 남게된다.
- 데이터베이스 트랜잭션에 각 테스트를 래핑하고 커밋하지 않기
  - 테스트와 SUT에서 변경한 모든 내용이 자동으로 롤백된다.
  - 추가 트랜잭션으로 인해 운영 환경과 다른 설정이 생성
- 테스트 시작 시점에 데이터 정리하기
  - 빠르게 작동하고 일관이 없는 동작을 일으키지 않으며 정리 단계를 실수로 건너뛰지않는다.

### 10.3.3 인메모리 데이터베이스 피하기
#### 장점
- 테스트 데이터 제거할 필요없음
- 작업 속도 향상
- 테스트가 실행될때마다 인스턴스화 가능
#### 사용하면 안되는 이유
- 일반 데이터베이스와 기능적으로 일관성이 없기 때문에 사용하지 않는것이 좋다.
- 운영 환경과 테스트 환경이 일치하지 않는 문제 로 테스트에서 거짓양성 또는 거짓 음성이 발생할수도 있다.
