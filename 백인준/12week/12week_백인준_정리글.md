# [Unit Testing] 8장 통합 테스트를 하는 이유

## 8.1 통합 테스트는 무엇인가?

### 8.1.1 통합 테스트의 역할
- 단위테스트 세가지 요구사항
  - 단일 동작 단위를 검증
  - 빠르게 수행
  - 다른 테스트와 별도로 처리
- 위 세가지 요구 사항 중 하나라도 충족하지 못한 테스트는 통합 테스트의 범주
![코드복잡도](https://user-images.githubusercontent.com/58027908/232287740-d7b4c0f6-e39b-46cf-85cd-80698fb3f84b.png)
- 컨트롤러 사분면에 속하는 코드를 다룬다.
- 프로세스 외부 의존성과 도메인 모델을 연결하는 코드를 확인

### 8.1.2 다시 보는 테스트 피라미드
- 통합 테스트가 프로세스 외부 의존성에 직접 작동하면 느려지며 테스트 유지비가 많이든다.
- 유지비 증가이유
  - 프로세스 외부 의존성 운영이 필요함
  - 관련된 협력자가 많아서 테스트가 비대해짐
- 통합 테스트는 코드를 많이 거치므로 회귀방지가 우수하고 제품코드와의 결합도가 낮아서 리팩터링 내성도 우수
- 단위 테스트는 가능한 많이 비즈니스 시나리오의 예외 상황을 확인하고 , 통합 테스트는 주요 흐름과 단위 테스트가 다루지 못하는 
기타 예외 상황을 다룬다.
- 대부분을 단위테스로 전환하면 유지비 절감 가능, 중요한 통합 테스트가 비즈니스 시나리오당 하나 또는 두개 있으면 시스템 전체의 정확도를 보장

### 8.1.3 통합 테스트와 빠른실패
- 빠른실패 원칙 : 버그를 빨리 나타나게 하는 것
  - 피드백 루프 단축: 버그를 빨리 발견할수록 더쉽게 해결가능
  - 지속성 상태 보호: 빨리 실패하면 손상이 확산되는것을 막을수 있다.

## 8.2 어떤 외부 의존성를 직접 테스트 해야하는가?

### 8.2.1 프로세스 외부 의존성의 두가지 유형
- 관리 의존성: 애플리케이션을 통해서만 접근 가능 해당 의존성과의 상호 작용은 외부 환경에서 볼수 없다.
  - API 를 통해 접근한다.  
  - 예 : 데이터베이스
- 비관리 의존성: 해당 의존성과의 상호작용은 외부에서 볼수있다. 
  - 예 : SMTP 서버, 메세지버스
- 관리 의존성과의 통신은 구현 세부사항,비관리 의존성과의 통신은 시스템의 식별할수 있는 동작
- 비관리 의존성은 목을 사용하여 하위호환 을 지킨다.
- 관리의존성은 데이터베이스같은 실제 인스턴스를 사용한다.

### 8.2.2 관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기
- 데이터베이스는 관리의존성이면서 비관리 의존성 
- 다른시스템이 같은 데이터베이스의 데이터를 요구
  - 이때 다른 애플리케이션에서 볼수있는 테이블을 비관리 의존성으로 취급  (사실상 메세지버스 역할)
  - 통신 패턴이 바뀌지 않도록 목을 사용

### 8.2.3 통합 테스트에서 실제 데이터베이스를 사용할 수 없으면 어떻게 할까?
- 데이터베이스를 그대로 테스트 할수없으면 통합 테스트를 아예 작성하지 말고 도메인 모델의 단위테스트에만 집중 해라

## 8.3 통합테스트: 예제

### 8.3.1 어떤 시나리오를 테스트 할까?
```java
public void Changing_email_from_corporate_to_non_corporate(){}
```
- 기업 이메일에서 일반 이메일로 변경하는 것 (가장 사이드 이펙트가 많다.)

### 8.3.2 데이터베이스와 메시지 버스 분류하기
- 통합테스트 작성전 프로세스 외부 의존성을 두 가지로 분류해서 직접 테스트할 대상과 목으로 대체할 대상을 결정해야한다.
- 데이터베이스는 관리 의존성이므로 실제 인스턴스를 사용하여야 한다.
- 메시지 버스는 비관리 의존성 (다른 시스템과의 통신을 가능하게 하는 것뿐) 목으로 대체한다.

### 8.3.3 엔드 투 엔드 테스트는 어떤가?
- 엔드 투 엔드 테스는 작동하는 버전의 API로 테스트 하게되고 어떤 프로세스 외부 의존성도 목을 대체하지않는것을 의미
- 통합 테스트는 비관리 의존성을 목으로 대체한다.

## 8.4 의존성 추상화를 위한 인터페이스 사용

### 8.4.1 인터페이스와 느슨한 결합
- 인터페이스 일반적이유
  - 프로세스 외부 의존성을 추상화해 느슨한 결합을 달성
  - 기존 코드를 변경하지 않고 새로운 기능을 추가해 공개 폐쇄 원칙을 지키기 때문
- 두 이유는 오해 - 단일 구현을 위한 인터페이스는 추상화가 아니고 구체 클래스보다 결합도가 낮지 않다.
- 두번째 이유 - 더 기본적인 원칙인  YAGNI를 위반하기 때문에 잘못된 생각

### 8.4.2 프로세스 외부 의존성에 인터페이스를 사용하는 이유는 무엇인가?
- 목을 사용하기 위함
  - 인터페이스가 없으면 테스트 대역을 만들수가 없으므로 테스트 대상 시스템과 프로세스 외부 의존성간의 상호 작용을 확인 할수 없다.
- 의존성을 목으로 처리할 필요가 없는한 프로세스 외부 의존성에 대한 인터페이스를 두지말라 비관리 의존성만 목으로 처리

### 8.4.3 프로세스 내부 의존성을 위한 인터페이스 사용
- 프로세스 외부 의존성과 달리 도메인 클래스 간의 상호작용을 확인해서는 안된다.
  - 깨지기 쉬운 테스트로 이어지고 결국 리팩터링 내성이 떨어지게 된다.
