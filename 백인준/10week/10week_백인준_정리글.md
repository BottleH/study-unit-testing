# [Unit Testing] 7장 가치 있는 단위 테스트를 위한 리팩터링

## 7.1 리팩터링할 코드 식별하기
### 7.1.1 코드의 네가지 유형

- 복잡도
  - 코드내 의사결정 지점수로 저의
- 도메인 유의성
  - 코드가 프로젝트의 문제 도메인에 얼마나 의미 있는지
- 복잡한 코드와 도메인 유의성을 갖는 코드가 단위 테스트에서 가장 이롭다 (회귀방지가 뛰어나기 때문에)
- 협력자수
  - 가변 의존성 혹은 프로세스 외부 의존성
  - 협력자가 많은 코드는 테스트 비용이 많이든다. (유지비 증가)
  - 도메인 모델이라면 외부 협력자를 사용하면 안된다.
- 네가지의 코드 유형
  - ![코드복잡도](https://user-images.githubusercontent.com/58027908/232287740-d7b4c0f6-e39b-46cf-85cd-80698fb3f84b.png)
  - 도메인 모델과 알고리즘
  - 간단한 코드
  - 컨트롤러
  - 지나치게 복잡한 코드
  - 좌측 상단 사분면 을 단위테스트를 하면 가치있고 저렴 해당코드가 복잡하거나 중요한 로직을 수행해서 테스트의 회귀 방지가 향상되기 떄문에 가치가 있다.
###7.1.2 험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기
- 테스트 대상 코드의 로직을 테스트하려면, 테스트가 가능한 부분을 추출 (테스트가 가능한 부분을 둘러싼 얇은 험블 래퍼가 된다.)
- ![험블](https://user-images.githubusercontent.com/58027908/232288214-eecca3b8-24d5-4d22-be09-a25fc716098e.png)
- 단일 책임원칙을 지키는것
  - 이 패턴을 적용하면 비즈니스 로직을 거의 모든것과 분리할 수 있다.
  - MVP MVC 패턴
    - 비즈니스 , UI, 모델과 뷰사이의 조정을 분리
  - 도메인 주도설계의 aggregate pattern 
    - 클래스를 클러스터로 묶어 클래스간의 연결을 줄인다.
    - 클래스는 클러스터 내부에 강하게 결합되어있지만 클러스터는 느슨하게 연결되어 코드 총 통신수를 줄인다.
- 분리를 하면 코드 복잡도를 해결할수 있다.

##7.2 가치있는 단위 테스트를 위한 리팩터링하기

###고객 관리 시스템 소개
- 사용자 이메일이 회사 도메인에 속한 경우 해당 사용자는 직원으로 표시
- 시스템은 회사의 직원수를 추적해야한다.
- 이메일이 변경되면 시스템은 메시지 버스로 메시지를 보내 외부 시스템에 알려야 한다.
- User 클래스 네개의 의존성
  - userId , newEmail 은 명시적 의존성
  - database , messagebus 는 암시적 의존성
- 도메인 유의성이 높은 코드는 프로세스 외부 협력자를 사용하면 안된다.
- 활성 레코드 패턴
  - 도메인 클래스가 스스로 데이터베이스를 검색하고 다시 저장하는 방식

### 1단계 : 암시적 의존성을 명시적으로 만들기
- 암시적 의존성인 데이터 베이스와 메시지 버스에 대한 인터페이스를 두고 이 인터페이스에 User에 주입 한후 테스트에서 목으로 처리
- 해당 의존성은 여전히 외부에 있기때문에 테스트를 하려면 복잡한 목체계가 있어야 하므로 테스트 유지비가 증가한다.
- 목을 데이터 베이스에 사용하게 되면 테스트 취약성 야기
- 도메인 모델은 프로세스 외부 협력자에게 의존하지 않는것이 훨씬 더 깔끔

### 2단계 : 애플리케이션 서비스 계층 도입
- 도메인 모델이 외부 시스템과 직접 통신하는 문제를 극복하기 위해서는 험블 컨트롤러로 책임을 옮긴다.

### 3단계 : 애플리케이션 서비스 복잡도 낮추기
- userController 가 컨트롤러 사분면에 확실히 있으려면 재구성 로직을 추출
  - ORM 라이브러리를 사용하여 데이터베이스를 도메인 모델에 매핑하면 재구성 로직을 옮기기에 적절한 위치가 될수있다.
  - ORM 을 사용하지 않으면 팩토리 클래스를 작성
- 재구성 로직은 도메인 유의성이 없다.

### 4단계 : 새 Company 클래스 소개
- 모든 복잡도가 팩토리로 이동하였기 때문에 userController 는 확실히 컨트롤러 사분면에 속한다.
- 함수형 아키텍처와 유사한점
  - 프로세스 외부 의존성과 통신하지 않는다.
  - 두가지 모두 애플리케이션 서비스 계층이 해당 통신을 담당
- 차이(사이드 이펙트 처리에 있다.)
  - 함수형은 어떤 사이드 이펙트도 일으키지 않는다.
  - CRM 의 도메인 모델은 사이드 이펙트를 일으키지만 마지막 까지 모든 사이드 이펙트가 메모리에 남아있어 테스트 용이성이 크게 향상된다.
