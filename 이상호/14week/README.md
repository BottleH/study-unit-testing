# Unit Testing : 생산성과 품질을 위한 단위 테스트 원칙과 패턴

이 내용은 [단위 테스트 생산성과 품질을 위한 단위 테스트 원칙과 패턴]을 읽으면서 정리한 내용을 포함하고 있습니다.

- 9장 목 처리에 대한 모범 사례 : 9.1 ~ 9.2

목차는 다음과 같습니다.

- 9.1 목의 가치를 극대화하기
- 9.2 목 처리에 대한 모범 사례

## 9장 목 처리에 대한 모범 사례

**목의 활용성**

- 테스트 대상 시스템과 의존성 간의 상호 작용을 모방하고 검사하는데 도움이 되는 테스트 대역
- 비관리 의존성(외부 애플리케이션에서 식별할 수 있음)에만 적용

여기서는 목에 대해 리팩터링 내성과 회귀 방지를 최대화해서 최대 가치의 통합 테스트를 개발하는 데 도움이 되는 내용을 알아본다.

### 9.1 목의 가치를 극대화하기

목의 가치를 극대화 하는 방법

- 비관리 의존성에만 목을 사용

#### 9.1.1 시스템 끝에서 상호 작용 검증하기

시스템 끝에서 비관리 의존성과의 상호 작용을 검증한다.

환율 정보를 받아오는 API가 있다고 가정해보자.

`Client -> Controller -> Service -> 외부 환율 서버`

- `Service` 에서 환율 서버 호출을 Mock으로 처리
- 통합 테스트로 검증된 코드가 더 많기 때문에 회귀 방지가 높다.
- 코드의 구현 세부 사항에서 목을 분리하였기 때문에 리팩터링 내성이 높다.

#### 9.1.2 목을 스파이로 대체하기

스파이는 직접 작성한 목이다.

- 직접 작성하였다는 키워드를 통해서 기존에 알고 있는 Spy 보다는 Fake 객체가 떠오른다.
- [[엘레강트 오브젝트] 2.8 모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요](https://lovethefeel.tistory.com/167)

Spy 활용 사례는 다음을 참고한다.

- [Spy 사례1 - 테스트 대상 Mocking 하기](https://jojoldu.tistory.com/239)

### 9.2 목 처리에 대한 모범 사례

다음 내용을 확인해보겠다.

- 통합 테스트에서만 목을 사용하고 단위 테스트에서는 하지 않기
- 항상 목 호출 수 확인하기
- 보유 타입만 목으로 처리하기

#### 9.2.1 목은 통합 테스트만을 위한 것

**Mock**

- 통합 테스트만을 위한 것이며, 단위 테스트에서 목을 사용하면 안 된다.
- 도메인 모델은 단위 테스트로 처리한다.
- 서비스 또는 컨트롤러 테스트에서는 비관리 의존성이 있는 경우에 목을 사용한다.

#### 9.2.2 테스트당 목이 하나일 필요는 없음

기본적인 오해 : 단위 테스트에서의 `단위` 는 코드 단위를 나타내며, 이러한 모든 단위는 서로 격리해 테스트해야 한다는 것

- 코드 단위가 아니라 동작 단위를 의미
- 동작 단위를 구현하는 데 필요한 코드의 양은 관계 없음
- 단일 클래스부터 여러 클래스까지 포함할 수 있고, 아주 작은 메서드일 수 있음

이는 목을 사용해도 같은 원칙을 적용 받는다.

- 동작 단위를 검증하는 데 필요한 목의 수는 관계 없음

#### 9.2.3 호출 횟수 검증하기

비관리 의존성과의 통신에 관해서 다음 두 가지 모두 확인하는 것이 중요하다.

- 예상하는 호출이 있는가?
- 예상치 못한 호출은 없는가?

애플리케이션은 외부 시스템이 예상하는 메시지를 생략해서는 안 되며 예상치 못한 메시지도 생성해서는 안 된다. 테스트 대상 시스템이 다음과 같이 메시지를 전송하는지 확인하는 것만으로 충분하지 않다.

```java
verify(messageBus).sendEmailChangedMessage(user.getUserId(), user.getEmail());
```

한번만 호출하는지 확인해봐야 한다.

```java
verify(messageBus, times(1)).sendEmailChangedMessage(user.getUserId(), user.getEmail());
```

#### 9.2.4 보유 타입만 목으로 처리하기

외부 의존성에 대해서 기본 타입 대신 해당 어댑터를 목으로 처리해야 한다.

- 내부 의존성에는 적용되지 않는다.

어댑터는 코드와 외부 환경 사이의 손상 방지 계층으로 작동한다.

- 기본 라이브러이의 복잡성을 추상화하고
- 라이브러리에서 필요한 기능만 노출하며
- 프로젝트 도메인 언어를 사용해 수행 가능