# Chapter 5. 목과 테스트 취약성

- 5장에서 다루는 내용
    - 목과 스텁 구분
    - 식별할 수 있는 동작과 구현 세부 사항 정의
    - 목과 테스트 취약성 간의 관계 이해
    - 리팩터링 내성 저하 없이 목 사용하기

## 5.1 목과 스텁 구분

### 5.1.1 테스트 대역 유형 

- 테스트 대역
  - 모든 유형의 비운영용 가짜 의존성을 설명하는 포괄적 용어 

- 테스트 대역은 목(목, 스파이), 스텁(스텁, 더미, 페이크) 두 가지 유형으로 나눌 수 있다
- 두 유형의 차이점
  - 목은 외부로 나가는 상호 작용을 모방하고 검사하는데 도움을 줌. 이러한 상호 작용은 SUT가 상태를 변경하기 위한 의존성을 호출하는 것에 해당
  - 스텁은 내부로 들어오는 상호 작용을 모방하는데 도움을 줌. 이러한 상호작용은 SUTㄱ 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당


### 5.1.2 도구로서의 목과 테스트 대역으로서의 목

- 도구로서의 목(Mock)과 테스트 대역으로서의 목(mock)을 구분 짓자
- 도구로서의 목을 사용해 목과 스텁 모두 만들 수 있다

### 5.1.3 스텁으로 상호 작용을 검증하지 말라

- 스텁은 SUT가 생성하는 최종 결과가 아닌 최종 결과를 산출하기 위한 수단
- 스텁과의 상호 작용을 검증하는 것은 취약한 테스트를 야기하는 일반적인 안티 패턴이다.

### 5.1.4 목과 스텁 함께 쓰기

- 스텁은 검증하지 말아야 하지만 스텁 내에서 호출된 다른 메소드가 실행되었는지 verify 하는 것은 괜찮다

### 5.1.5 목과 스텁은 명령과 조회에 어떻게 관련이 있는가?

- 목과 스텁의 개념은 명령 조회 분리 원칙(Command Query Separation)과 관련이 있다
- CQS원칙
  - 모든 메서드는 명령이거나 조회여야 하며, 이 둘은 혼용해서는 안 된다.
- 명령은 사이드 이펙트를 일으키고 반환 값이 없고(void) 조회는 반대로 사이드 이펙트를 일으키지 않고 값을 반환한다.
- 명령을 대체하는 테스트 대역-> 목, 조회를 대체하는 테스트 대역 -> 스텁

## 5.2 식별할 수 있는 동작과 구현 세부사항

- 4장에서 테스트에 거짓 양성이 있는 주요 이뉴는 코드의 구현 세부사항과 결합돼 있기 떄문
- 이를 피하기 위해 코드가 생성하는 최종 결과(식별할 수 있는 동작)를 검증하고 구현 세부사항과 테스트를 가능한 한 떨어뜨림.

### 5.2.1 식별할 수 있는 동작은 공개 API와 다르다

- 모든 제품 코드는 다음처럼 분류
  - 공개 API와 비공개 API
  - 식별할 수 있는 동작과 구현 세부사항
- 식별할 수 있는 동작이란
  - 클라이언트가 목표를 달성하는 데 도움이 되는 연산을 노출하라. 연산은 계산을 수행하거나 사이드 이펙트를 초래하거나 둘 다 하는 메서드이다
  - 클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출하라. 상태는 시스템의 현재 상태다
- 이상적으로 시스템의 공개 API는 식별할 수 있는 동작과 일치해야하며 모든 구현 세부 사항은 클라이언트 눈에 보이지 않아야 함

### 5.2.2 구현 세부 사항 유출: 연산의 예

- 구현 세부 사항을 유출하는 User 클래스

```java
public class User{
    public String name;
    
    public String getName(){
        return name;
    }
    
    public void setName(String name){
        this.name = name;
    }
    
    public String normalizeName(String name){
        String result = name;
        
        if(result.length() > 50)
            return result.subString(0, 50);
        
        return result;
    }
}
```

- API 잘 설계된 User 클래스

```java
public class User{
    public String name;
    
    public String getName(){
        return name;
    }
    
    public void setName(String name){
        this.name = normalizeName(name);
    }
    
    private String normalizeName(String name){
        String result = name;
        
        if(result.length() > 50)
            return result.subString(0, 50);
        
        return result;
    }
}
```

### 5.2.3 잘 설계된 API와 캡슐화

- 코드 복잡도에 대응하기 위하여 캡슐화가 중요

### 5.2.4 구현 세부 사항 유출: 상태의 예

|        | 식별할 수 있는 동작 | 구현 세부 사항 |
| ------ | ------------------- | -------------- |
| 공개   | 좋음                | 나쁨           |
| 비공개 | 해당 없음           | 좋음           |

