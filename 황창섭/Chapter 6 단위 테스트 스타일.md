# Chapter 6. 단위 테스트 스타일

# Chapter 6. 단위 테스트 스타일

- 단위 테스트 스타일에 대한 비교
- 함수형 아키텍처와 육각형 아키텍처의 관계
- 출력 기반 테스트로 전환
- 단위 테스트 스타일에는 출력 기반, 상태 기반, 통신 기반이라는 세 가지 스타일이 있다
- 출력 기반 테스트 스타일이 가장 품질이 좋지만 아무데서나 사용할 수 없지만 함수형 프로그래밍 원칙을 사용해 기반 코드가 함수형 아키텍처를 지향하게끔 재구성하여 변환하는 기법 소개

## 6.1 단위 테스트의 세 가지 스타일

- 출력 기반 테스트
- 상태 기반 테스트
- 통신 기반 테스트

### 6.1.1 출력 기반 테스트 정의

- SUT에 입력을 넣고 생성되는 출력을 점검하는 방식
- 출력 기반 테스트는 내부 컬렉션에 상품을 추가하거나 데이터베이스에 저장하지 않음
- 다시 말해 사이드 이펙트가 없는 코드 선호를 강조하는 함수형 프로그래밍에 뿌리를 둠

### 6.1.2 상태 기반 스타일 정의

- 상태 기반 스타일은 작업이 완료된 후 시스템 상태를 확인하는 것
- 상태는 SUT나 협력자 중 하나, 또는 데이터베이스나 파일 시스템 등과 같은 프로세스 외부 의존성 등을 의미

### 6.1.3 통신 기반 스타일 정의

- 목을 사용해 SUT와 협력자 간의 통신을 검증

## 6.2 단위 테스트 스타일 비교

- 좋은 단위 테스트의 4대 요소(회귀 방지, 리팩터링 내성, 빠른 피드백, 유지 보수성)로 스타일을 비교

### 6.2.1 회귀 방지와 피드백 속도 지표로 스타일 비교하기

- 회귀 방지 지표와 피드백 속도는 특정 스타일에 따라 크게 달라지지 않는다.

### 6.2.2 리팩터링 내성 지표로 스타일 비교하기

- 리팩터링 내성은 리팩터링 중에 발생하는 거짓 양성 수에 대한 척도다. 결국 거짓 양성은 식별할 수 있는 동작이 아니라 코드의 구현 세부사항에 결합된 테스트의 결과다.
- **출력 기반 테스트**는 테스트 대상 메서드에만 결합되므로 거짓 양성 방지가 가장 우수
- **상태 기반 테스트**는 SUT 외에도 클래스 상태와 함께 작동하므로 결합도가 높다는 의미가 되며 이는 구현 세부 사항에 테스트가 얽매일 가능성이 높음을 시사함
- **통신 기반 테스트**가 거짓 양성에 가장 취약하다. 테스트 대역으로 상호 작용을 확인하는 테스트는 대부분 깨지기 쉬움(5장 내용)

### 6.2.3 유지 보수성 지표로 스타일 비교하기

- 유지 보수성 지표는 단위 테스트 스타일과 밀접한 관련이 있다
- 유지 보수성 지표
    - 테스트를 이해하기 얼마나 어려운가?
    - 테스트를 실행하기 얼마나 어려운가?
- 출력 기반 테스트의 유지 보수성
    - 출력 기반 테스트는 거의 항상 짧고 간결하므로 유지 보수가 쉽다
- 상태 기반 테스트의 유지 보수성
    - 상태 검증은 종종 출력 검증보다 더 많은 공간을 차지하기에 출력 기반 테스트보다 유지 보수가 어렵다
- 통신 기반 테스트의 유지 보수성
    - 통신 기반 테스트에는 테스트 대역과 상호 작용 검증을 설정해야 하기에 공간을 더 많이 차지한다 → 유지 보수가 어려워진다

### 6.2.4 스타일 비교하기: 결론

- 출력 기반 테스트 > 상태 기반 테스트 > 통신 기반 테스트 순으로 좋은 품질의 단위 테스트를 구성할 수 있다
- 하지만 출력 기반 스타일은 함수형으로 작성된 코드에만 적용되기에 대부분의 객체지향 프로그래밍 언어에는 해당하지 않음
- 이후 내용에서 상태 기반 테스트와 통신 기반 테스트를 출력 기반 테스트로 바꾸는 기법을 안내

## 6.3 함수형 아키텍처 이해

- 함수형 프로그래밍과 함수형 아키텍처가 무엇인지 알아보고, 함수형 아키텍처와 육각형 아키텍처가 어떤 관련이 있는지 살펴봄

### 6.3.1 함수형 프로그래밍이란?

- 함수형 프로그래밍은 수학적 함수를 사용한 프로그래밍
- 즉 숨은 입출력이 없고 호출 횟수에 상관없이 주어진 입력에 대해 동일한 출력을 생성해야함
- 테스트를 어렵게 만드는 숨은 입출력이란?
    - 사이드 이펙트: 사이드 이펙트는 메서드 시그니처에 표시되지 않는 출력
    - 예외: 메서드가 예외를 던지면 메서드 시그니처에 설정된 계약을 우회하는 경로를 가짐
    - 내외부 상태에 대한 참조: Datetime.now, 데이터베이스 조회 등
- 수학적 함수 예제

```java
public int Increment(int x){
  return x+1;
}
```

- 수학적 함수가 아닌 예제

```java
int x = 0;
public int Increment(){
  return ++x;
}
```

```java
public Comment addComment(String text){
   var comment = new Comment(text);
   _comments.add(comment);
   return comment;
}
```

### 6.3.2 함수형 아키텍처란?

- 사이드 이펙트를 일으키지 않는 애플리케이션은 비현실적
- 함수형 프로그래밍의 목표는 사이드 이펙트를 완전히 제거하는 것이 아닌 비즈니스 로직을 처리하는 코드와 사이드 이펙트를 일으키는 코드를 분리하는 것
- 하지만 이 두 가지를 모두 고려하면 복잡도가 배가되고 장기적으로 코드 유지 보수성을 방해한다
- 함수형 아키텍처는 사이드 이펙트를 비즈니스 연산 끝으로 몰아서 비즈니스 로직을 사이드 이펙트와 분리하는 것
- 비즈니스 로직과 사이드 이펙트를 분리하기 위한 두 가지 코드유형
    - 결정을 내리는 코드: 사이드 이펙트 없음, 수학적 함수
    - 해당 결정에 따라 작용하는 코드: 수학적 함수에 의해 이뤄진 모든 결정을 데이터베이스 변경과 같은 가지적인 부분으로 변환
- 결정을 내리는 코드를 functional core 또는 immutable core라 칭하고 해당 결정에 따라 작용하는 코드를 mutable shell이라 칭함
- 함수형 코어와 가변 셸의 협력 방식
    - 가변 셸은 모든 입력을 수집
    - 함수형 코어는 결정을 생성
    - 가변 셸은 결정을 사이드 이펙트로 변환

### 6.3.3 함수형 아키텍처와 육각형 아키텍처 비교

- 두 가지 모두 관심사 분리하는 아이디어를 기반으로 함
- 유사점 1.
    - 육각형 아키텍처는 도메인 계층과 애플리케이션 서비스 계층으로 분리
    - 도메인 계층: 비즈니스 로직
    - 애플리케이션 서비스 계층: 데이터베이스나 외부 애플리케이션과의 통신 책임
    - 이는 결정과 실행을 분리하는 함수형 아키텍처와 매우 유사
- 유사점 2.
    - 의존성 간의 단방향 흐름
    - 도메인 계층 내 클래스는 서로에게만 의존하듯 함수형 아키텍처의 불변 코어는 가변 셸에 의존하지 않는다
- 두 아키텍처의 차이점은 사이드 이펙트에 대한 처리이다
- 함수형 아키텍처는 모든 사이드 이펙트를 불변 코어에서 비즈니스 연산 가장자리로 밀어내고 가장자리는 가변 셸이 처리함
- 반면 육각형 아키텍처의 모든 수정 사항은 도메인 계층 내에 있어야 하며 계층의 경계를 넘어서는 안됨